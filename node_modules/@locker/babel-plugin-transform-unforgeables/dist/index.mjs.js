import { types, template } from '@babel/core';
import { CodeGenerator } from '@babel/generator';
import { partial } from 'match-json';

const BABEL_GENERATE_OPTIONS = {
    comments: false,
    compact: true,
    sourceMaps: false,
};
// Based on the pseudo private `_generateUid` from '@babel/traverse':
// https://github.com/babel/babel/blob/v7.21.2/packages/babel-traverse/src/scope/index.ts
// eslint-disable-next-line @typescript-eslint/naming-convention, no-underscore-dangle
function _generateUid(name, i) {
    let id = name;
    if (i > 1) {
        id += i;
    }
    return `_${id}`;
}
function generateCode(ast) {
    // This lets us deeply compare nodes in a way that ignores extraneous properties,
    // like location and other metadata. This method is performance HEAVY so we
    // try to call it last AFTER performing lighter checks first.
    const gen = new CodeGenerator(ast, BABEL_GENERATE_OPTIONS);
    return gen.generate().code;
}
// istanbul ignore next: currently unreachable via tests
function isNonArrowFunction(path) {
    return path.isFunction() && !path.isArrowFunctionExpression();
}
function isUpdateExpression(path) {
    return path.isUpdateExpression();
}
function stripUid(name) {
    // This method follows Babel's style of decoration removal.
    // https://github.com/babel/babel/blob/v7.21.2/packages/babel-traverse/src/scope/index.ts#L496-L498
    return name.replace(/^_+/, '').replace(/[0-9]+$/g, '');
}
// istanbul ignore next: currently unreachable via tests
function alwaysFalse() {
    return false;
}
function generateUid(cache, name) {
    // This gives our generated unique identifiers the look and feel of those
    // created with Babel's `Scope#generateUid` while letting us use our own
    // backing cache.
    const baseName = stripUid(types.toIdentifier(name));
    let uid = baseName;
    let i = 1;
    while (cache.has(uid)) {
        uid = _generateUid(baseName, i);
        i += 1;
    }
    return uid;
}
function getAllBindingNames(programScope) {
    // Collect ALL bindings from ALL scopes. This is our simple approach to
    // avoiding variable conflicts when generating unique identifiers.
    const allNames = new Set(Object.keys(programScope.bindings));
    programScope.traverse(programScope.path.node, {
        Scope({ scope: { bindings } }) {
            const names = Object.keys(bindings);
            for (let i = 0, { length } = names; i < length; i += 1) {
                allNames.add(names[i]);
            }
        },
    });
    return allNames;
}
function isAssignOrConcat(operator) {
    return operator === '=' || operator === '+=';
}
function isDoubleOrTripleEquals(operator) {
    // Minifiers may convert `===` to `==`.
    return operator === '===' || operator === '==';
}
function isGlobalIdentifier(path) {
    return (path.isIdentifier() &&
        // Globals are not bindings in any scope.
        // Passing `true` for `noGlobals` avoids lookups in `Scope.globals`
        // and `Scope.contextVariables` arrays to only match actual bindings
        // created in a scope.
        !path.scope.hasBinding(path.node.name, /* noGlobals */ true) &&
        // Perform an extra check for an identifier named 'arguments' to ensure
        // it doesn't belong to a function.
        (path.node.name !== 'arguments' ||
            /* istanbul ignore next: currently unreachable via tests */ !path.findParent(isNonArrowFunction)));
}
function isNodeEquals(...args) {
    const { length } = args;
    let prev;
    for (let i = 0; i < length; i += 1) {
        if (prev === undefined) {
            prev = generateCode(args[i]);
        }
        else if (generateCode(args[i]) !== prev) {
            return false;
        }
    }
    return length > 0;
}
function isLeftOfAssignment(path) {
    return (!!path.parentPath &&
        path.parentPath.isAssignmentExpression() &&
        path.parent.left === path.node);
}
function isLocationIdentifier(path) {
    return path.isIdentifier({ name: 'location' });
}
function isLocationProperty(path) {
    return path.isMemberExpression() && path.get('property').isIdentifier({ name: 'location' });
}
function isTopProperty(path) {
    return path.isMemberExpression() && path.get('property').isIdentifier({ name: 'top' });
}
function isWithinUpdateExpression(path) {
    return path.findParent(isUpdateExpression) !== null;
}

function collectGlobalAliases({ bindings }, { globals: { toIds } }) {
    // Scan top-level bindings for possible global alias assignments to allow
    // for our builder's replacement values.
    const bindingNames = Object.keys(bindings);
    for (let i = 0, { length } = bindingNames; i < length; i += 1) {
        const { identifier: id, path: { node: { init: initNode }, }, } = bindings[bindingNames[i]];
        if (types.isIdentifier(initNode)) {
            const { name } = initNode;
            const ids = toIds.get(name);
            // istanbul ignore else: currently unreachable via tests
            if (ids) {
                const shadowIndex = bindingNames.indexOf(name);
                const shadowPos = shadowIndex === -1
                    ? Infinity
                    : bindings[bindingNames[shadowIndex]].identifier.start;
                // Treat as a global alias if it is not shadowed by an earlier
                // top-level identifier.
                if (id.start < shadowPos) {
                    ids.push(id);
                }
            }
        }
    }
}
function createBuilderPluginState(programScope, { globals: { injected, toIds, toReplacement } }) {
    // The builder plugin state is limited to methods that interact with the
    // private plugin state without exposing raw data to builders.
    return {
        getGlobalReplacement(globalName) {
            const id = toReplacement.get(globalName);
            // istanbul ignore else: currently unreachable via tests
            if (id) {
                const { name: idName } = id;
                if (idName !== globalName && !injected.has(idName)) {
                    // Lazily inject on retrieval of replacement value to inject
                    // only when needed.
                    injected.add(idName);
                    programScope.push({
                        id,
                        init: types.identifier(globalName),
                    });
                }
            }
            return id;
        },
        isGlobalReplacement(globalName, idName) {
            // Perform the quick check first.
            if (idName === globalName) {
                return true;
            }
            const ids = toIds.get(globalName);
            return ids
                ? // Iterate over identifiers for a match.
                    ids.some(({ name }) => name === idName)
                : /* istanbul ignore next: currently unreachable via tests */ false;
        },
    };
}
function resolveGlobalReplacements({ meta: { globals: fromPlaceholder } }, { getAllBindingNames, globals: { toIds, toReplacement } }) {
    Object.values(fromPlaceholder).forEach((globalName) => {
        let ids = toIds.get(globalName);
        if (ids === undefined) {
            ids = [types.identifier(globalName)];
            toIds.set(globalName, ids);
        }
        let id = toReplacement.get(globalName);
        if (id) {
            return;
        }
        const uid = generateUid(getAllBindingNames(), globalName);
        if (globalName === uid) {
            // Use the default identifier at index 0.
            id = ids[0];
        }
        else {
            id = types.identifier(uid);
            // Replace the default identifier at index 0.
            ids[0] = id;
        }
        toReplacement.set(globalName, id);
    });
}
function initState(programScope, builders) {
    let allBindingNames;
    const privateState = {
        globals: {
            injected: new Set(),
            toIds: new Map(),
            toReplacement: new Map(),
        },
        getAllBindingNames() {
            if (allBindingNames === undefined) {
                allBindingNames = getAllBindingNames(programScope);
            }
            return allBindingNames;
        },
    };
    for (let i = 0, { length } = builders; i < length; i += 1) {
        const builder = builders[i];
        builder.setState(createBuilderPluginState(programScope, privateState));
        resolveGlobalReplacements(builder, privateState);
    }
    collectGlobalAliases(programScope, privateState);
}

const Builder = class Builder {
    // eslint-disable-next-line no-underscore-dangle
    /* istanbul ignore next: currently unreachable via tests */ get _state() {
        // @ts-ignore: Property does not exist error.
        throw new Error(`Builder ${JSON.stringify(this.name)} state not set.`);
    }
    // eslint-disable-next-line no-underscore-dangle
    set _state(value) {
        // Convert from an accessor to a data property.
        Reflect.defineProperty(this, '_state', {
            value,
            writable: true,
        });
    }
    // Having a "create" method allows us to have a return type of `BuilderClass`
    // instead of `Builder` which is imposed by the constructor.
    static create(code, options) {
        return new Builder(code, options);
    }
    constructor(code, 
    // istanbul ignore next: currently unreachable via tests
    { name = 'unnamed', globals = {}, validator = alwaysFalse } = {}) {
        const expression = template.expression(code);
        // Use a computed property to dynamically set the builder name without
        // using `Reflect.defineProperty()`.
        const { [name]: builder } = {
            [name]: (publicReplacements) => 
            // We manually wrap our expression in parenthesis because
            // `templateBuilder.expression` does not create them for us.
            types.parenthesizedExpression(expression(
            // Add global placeholder replacement identifiers.
            Object.entries(builder.meta.globals).reduce((replacements, { 0: placeholder, 1: globalName }) => {
                replacements[placeholder] =
                    builder.getGlobalReplacement(globalName);
                return replacements;
            }, { ...publicReplacements }))),
        };
        // eslint-disable-next-line no-underscore-dangle
        builder._validator = validator;
        // Storing metadata on the builder lets us decouple logic for global
        // alias detection and unique identifier injection.
        builder.meta = { globals: { ...globals } };
        Reflect.setPrototypeOf(builder, Builder.prototype);
        // eslint-disable-next-line no-constructor-return
        return builder;
    }
    getGlobalReplacement(globalName) {
        // eslint-disable-next-line no-underscore-dangle
        return this._state.getGlobalReplacement(globalName);
    }
    isGlobalReplacement(globalName, idName) {
        // eslint-disable-next-line no-underscore-dangle
        return this._state.isGlobalReplacement(globalName, idName);
    }
    isTransformed(path) {
        // eslint-disable-next-line no-underscore-dangle
        return this._validator(path);
    }
    setState(state) {
        // eslint-disable-next-line no-underscore-dangle
        this._state = state;
    }
};
Reflect.setPrototypeOf(Builder.prototype, Function.prototype);

const locationAssignTransform = () => 
// Used to replace the pattern:
// LOCATION = VALUE
Builder.create(`
            LOCATION.assign(VALUE)
        `, {
    name: 'locationAssignTransform',
    globals: { LOCATION: 'location' },
});

const locationConcatTransform = () => 
// Used to replace the pattern:
// LOCATION += VALUE
Builder.create(`
            LOCATION.assign(LOCATION.href + VALUE)
        `, {
    name: 'locationConcatTransform',
    globals: { LOCATION: 'location' },
});

const locationMemberTransform = () => 
// Used to replace the pattern:
// NODE.location
Builder.create(`
            (NODE === GLOBAL_THIS || NODE === DOCUMENT) ? LOCATION : EXPRESSION
        `, {
    name: 'locationMemberTransform',
    globals: { DOCUMENT: 'document', GLOBAL_THIS: 'globalThis', LOCATION: 'location' },
    validator(path) {
        const { node: memberExpr } = path;
        const { object } = memberExpr;
        const conditionalExpr = path.parent;
        const logicalExpr = conditionalExpr.test;
        return (
        // First, a light schema check.
        partial(conditionalExpr, 
        // JSON schema representing the expanded expression:
        // (NODE === GLOBAL_THIS || NODE === DOCUMENT) ? LOCATION : NODE.location
        {
            type: 'ConditionalExpression',
            alternate: (node) => node === memberExpr,
            consequent: {
                type: 'Identifier',
                name: (name) => this.isGlobalReplacement('location', name),
            },
            test: {
                type: 'LogicalExpression',
                operator: '||',
                left: {
                    type: 'BinaryExpression',
                    operator: isDoubleOrTripleEquals,
                    left: {
                        type: object.type,
                    },
                    right: {
                        type: 'Identifier',
                        name: (name) => this.isGlobalReplacement('globalThis', name),
                    },
                },
                right: {
                    type: 'BinaryExpression',
                    operator: isDoubleOrTripleEquals,
                    left: {
                        type: object.type,
                    },
                    right: {
                        type: 'Identifier',
                        name: (name) => this.isGlobalReplacement('document', name),
                    },
                },
            },
        }) &&
            // Then, a deep comparison:
            // (NODE === GLOBAL_THIS || NODE === DOCUMENT) ? LOCATION : NODE.location
            //  ^-----------------------^-------------------------------^
            isNodeEquals(logicalExpr.left.left, logicalExpr.right.left, object));
    },
});

const locationMemberAssignTransform = () => 
// Used to replace the pattern:
// NODE.location = VALUE
Builder.create(`
            (NODE === GLOBAL_THIS || NODE === DOCUMENT) ? LOCATION.assign(VALUE) : EXPRESSION
        `, {
    name: 'locationMemberAssignTransform',
    globals: { DOCUMENT: 'document', GLOBAL_THIS: 'globalThis', LOCATION: 'location' },
    validator(path) {
        const { node: assignmentExpr } = path;
        const { object } = assignmentExpr.left;
        const conditionalExpr = path.parent;
        const callExpr = conditionalExpr.consequent;
        const logicalExpr = conditionalExpr.test;
        return (
        // First, a light schema check.
        partial(conditionalExpr, 
        // JSON schema representing the expanded expression:
        // (NODE === GLOBAL_THIS || NODE === DOCUMENT) ? LOCATION.assign(VALUE) : NODE.location = VALUE
        {
            type: 'ConditionalExpression',
            alternate: (altNode) => altNode === assignmentExpr,
            consequent: {
                type: 'CallExpression',
                arguments: (args) => args.length === 1 && args[0].type === assignmentExpr.right.type,
                callee: {
                    type: 'MemberExpression',
                    object: {
                        type: 'Identifier',
                        name: (name) => this.isGlobalReplacement('location', name),
                    },
                    property: {
                        type: 'Identifier',
                        name: 'assign',
                    },
                },
            },
            test: {
                type: 'LogicalExpression',
                operator: '||',
                left: {
                    type: 'BinaryExpression',
                    operator: isDoubleOrTripleEquals,
                    left: {
                        type: object.type,
                    },
                    right: {
                        type: 'Identifier',
                        name: (name) => this.isGlobalReplacement('globalThis', name),
                    },
                },
                right: {
                    type: 'BinaryExpression',
                    operator: isDoubleOrTripleEquals,
                    left: {
                        type: object.type,
                    },
                    right: {
                        type: 'Identifier',
                        name: (name) => this.isGlobalReplacement('document', name),
                    },
                },
            },
        }) &&
            // Then, a hopefully less deep generated comparison:
            // (NODE === GLOBAL_THIS || NODE === DOCUMENT) ? LOCATION.assign(VALUE) : NODE.location = VALUE
            //                                                               ^________________________^
            isNodeEquals(callExpr.arguments[0], assignmentExpr.right) &&
            // Finally, a deep comparison:
            // (NODE === GLOBAL_THIS || NODE === DOCUMENT) ? LOCATION.assign(VALUE) : NODE.location = VALUE
            //  ^-----------------------^---------------------------------------------^
            isNodeEquals(logicalExpr.left.left, logicalExpr.right.left, object));
    },
});

const locationMemberConcatTransform = () => 
// Used to replace the pattern:
// NODE.location += VALUE
Builder.create(`
            (NODE === GLOBAL_THIS || NODE === DOCUMENT) ? LOCATION.assign(LOCATION.href + VALUE) : EXPRESSION
        `, {
    name: 'locationMemberConcatTransform',
    globals: { DOCUMENT: 'document', GLOBAL_THIS: 'globalThis', LOCATION: 'location' },
    validator(path) {
        const { node: assignmentExpr } = path;
        const { object } = assignmentExpr.left;
        const conditionalExpr = path.parent;
        const callExpr = conditionalExpr.consequent;
        const logicalExpr = conditionalExpr.test;
        return (
        // First, a light schema check.
        partial(conditionalExpr, 
        // JSON schema representing the expanded expression:
        // (NODE === GLOBAL_THIS || NODE === DOCUMENT) ? LOCATION.assign(LOCATION.href + VALUE) : NODE.location += VALUE
        {
            type: 'ConditionalExpression',
            alternate: (altNode) => altNode === assignmentExpr,
            consequent: {
                type: 'CallExpression',
                arguments: (args) => args.length === 1 &&
                    partial(args, [
                        {
                            type: 'BinaryExpression',
                            operator: '+',
                            left: {
                                type: 'MemberExpression',
                                object: {
                                    type: 'Identifier',
                                    name: (name) => this.isGlobalReplacement('location', name),
                                },
                                property: {
                                    type: 'Identifier',
                                    name: 'href',
                                },
                            },
                            right: {
                                type: assignmentExpr.right.type,
                            },
                        },
                    ]),
                callee: {
                    type: 'MemberExpression',
                    object: {
                        type: 'Identifier',
                        name: (name) => this.isGlobalReplacement('location', name),
                    },
                    property: {
                        type: 'Identifier',
                        name: 'assign',
                    },
                },
            },
            test: {
                type: 'LogicalExpression',
                operator: '||',
                left: {
                    type: 'BinaryExpression',
                    operator: isDoubleOrTripleEquals,
                    left: {
                        type: object.type,
                    },
                    right: {
                        type: 'Identifier',
                        name: (name) => this.isGlobalReplacement('globalThis', name),
                    },
                },
                right: {
                    type: 'BinaryExpression',
                    operator: isDoubleOrTripleEquals,
                    left: {
                        type: object.type,
                    },
                    right: {
                        type: 'Identifier',
                        name: (name) => this.isGlobalReplacement('document', name),
                    },
                },
            },
        }) &&
            // Then, a hopefully less deep generated comparison:
            // (NODE === GLOBAL_THIS || NODE === DOCUMENT) ? LOCATION.assign(LOCATION.href + VALUE) : NODE.location += VALUE
            //                                                                               ^_________________________^
            isNodeEquals(callExpr.arguments[0].right, assignmentExpr.right) &&
            // Finally, a deep comparison:
            // (NODE === GLOBAL_THIS || NODE === DOCUMENT) ? LOCATION.assign(LOCATION.href + VALUE) : NODE.location += VALUE
            //  ^-----------------------^-------------------------------------------------------------^
            isNodeEquals(logicalExpr.left.left, logicalExpr.right.left, object));
    },
});

function getTopObject(path) {
    let currPath;
    let nextPath = path;
    do {
        currPath = nextPath;
        // Walk into nested top member expressions like
        // window.top.top -> window.top -> window
        nextPath = currPath.get('object');
    } while (isTopProperty(nextPath));
    return currPath.node.object;
}
const topMemberTransform = () => 
// Used to replace the pattern:
// NODE.top
Builder.create(`
            NODE === GLOBAL_THIS ? TOP : EXPRESSION
        `, {
    name: 'topMemberTransform',
    globals: { GLOBAL_THIS: 'globalThis', TOP: 'top' },
    validator(path) {
        const { node: memberExpr } = path;
        const object = getTopObject(path);
        const conditionalExpr = path.parent;
        const binaryEpr = conditionalExpr.test;
        return (
        // First, a light schema check.
        partial(conditionalExpr, 
        // JSON schema representing the expanded expression:
        // NODE === GLOBAL_THIS ? TOP : NODE.top
        {
            type: 'ConditionalExpression',
            alternate: (node) => node === memberExpr,
            consequent: {
                type: 'Identifier',
                name: (name) => this.isGlobalReplacement('top', name),
            },
            test: {
                type: 'BinaryExpression',
                operator: isDoubleOrTripleEquals,
                left: {
                    type: object.type,
                },
                right: {
                    type: 'Identifier',
                    name: (name) => this.isGlobalReplacement('globalThis', name),
                },
            },
        }) &&
            // Then, a deep comparison:
            // NODE === GLOBAL_THIS ? TOP : NODE.top
            // ^----------------------------^
            isNodeEquals(binaryEpr.left, object));
    },
});

function transformUnforgeables() {
    const locationAssignTransformBuilder = locationAssignTransform();
    const locationConcatTransformBuilder = locationConcatTransform();
    const locationMemberTransformBuilder = locationMemberTransform();
    const locationMemberAssignTransformBuilder = locationMemberAssignTransform();
    const locationMemberConcatTransformBuilder = locationMemberConcatTransform();
    const topMemberTransformBuilder = topMemberTransform();
    return {
        name: 'babel-plugin-transform-unforgeables',
        visitor: {
            // Program() { ... } is shorthand for Program: { enter() { ... } }
            // and is visited first.
            Program(path) {
                initState(path.scope, [
                    locationAssignTransformBuilder,
                    locationConcatTransformBuilder,
                    locationMemberTransformBuilder,
                    locationMemberAssignTransformBuilder,
                    locationMemberConcatTransformBuilder,
                    topMemberTransformBuilder,
                ]);
            },
            Identifier(path) {
                // Only transform `location = value` and `location += value`.
                if (isLocationIdentifier(path) &&
                    isLeftOfAssignment(path) &&
                    isGlobalIdentifier(path)) {
                    const parent = path.parent;
                    const { operator } = parent;
                    if (isAssignOrConcat(operator)) {
                        const builder = operator === '='
                            ? locationAssignTransformBuilder
                            : locationConcatTransformBuilder;
                        const parentPath = path.parentPath;
                        // Both transform variations have the same placeholder
                        // replacements.
                        parentPath.replaceWith(builder({ VALUE: parent.right }));
                        parentPath.skip();
                    }
                }
            },
            // MemberExpression() { ... } visits children before parents, e.g.
            // `document.defaultView.top` before `document.defaultView`.
            MemberExpression(path) {
                const { node } = path;
                if (isLocationProperty(path)) {
                    const objectPath = path.get('object');
                    // Skip transforming location in members like `window.top.location`
                    // letting the transform to `window.top` carry it.
                    if (isTopProperty(objectPath)) {
                        return;
                    }
                    const alternatePath = objectPath.isConditionalExpression()
                        ? objectPath.get('alternate')
                        : undefined;
                    // Skip re-transforming location in members like
                    // `(window === GLOBAL_THIS ? TOP : window.top).location`.
                    if (alternatePath &&
                        isTopProperty(alternatePath) &&
                        topMemberTransformBuilder.isTransformed(alternatePath)) {
                        return;
                    }
                    if (isLeftOfAssignment(path)) {
                        const parent = path.parent;
                        const { operator } = parent;
                        // Only transform `NODE.location = value` and `NODE.location += value`.
                        if (isAssignOrConcat(operator)) {
                            const builder = operator === '='
                                ? locationMemberAssignTransformBuilder
                                : locationMemberConcatTransformBuilder;
                            const { parentPath } = path;
                            // Skip re-transforming location.
                            if (!builder.isTransformed(parentPath)) {
                                // Both transform variations have the same
                                // placeholder replacements.
                                parentPath.replaceWith(builder({
                                    EXPRESSION: parent,
                                    NODE: node.object,
                                    VALUE: parent.right,
                                }));
                                parentPath.skip();
                            }
                        }
                    }
                    else if (
                    // Skip transforming `++NODE.location` and `NODE.location++`.
                    !isWithinUpdateExpression(path) &&
                        // Skip re-transforming location.
                        !locationMemberTransformBuilder.isTransformed(path)) {
                        path.replaceWith(locationMemberTransformBuilder({
                            EXPRESSION: node,
                            NODE: node.object,
                        }));
                        path.skip();
                    }
                }
                else if (isTopProperty(path) &&
                    // Unlike location, we skip transforming assignments to
                    // top because it's essentially a no-op.
                    !isLeftOfAssignment(path) &&
                    // Skip transforming `++NODE.top` and `NODE.top++`.
                    !isWithinUpdateExpression(path)) {
                    let currPath;
                    let nextPath = path;
                    do {
                        currPath = nextPath;
                        currPath.skip();
                        // Walk into nested top member expressions like
                        // window.top.top -> window.top -> window
                        nextPath = currPath.get('object');
                    } while (isTopProperty(nextPath));
                    // Skip re-transforming top.
                    if (!topMemberTransformBuilder.isTransformed(path)) {
                        path.replaceWith(topMemberTransformBuilder({
                            EXPRESSION: node,
                            NODE: currPath.node.object,
                        }));
                        path.skip();
                    }
                }
            },
        },
    };
}

export { transformUnforgeables as default };
