import { Node, BaseNode, NodeT, NodeTypes } from './helpers';
import { TraverseOptions, Visitors } from './traverse';
import { Scope } from './scope';
import * as t from './generated/types';
import { NodePathDocs } from './nodepath-doc';
export declare class Context {
    /**
     * Don't depend on `pathCache` to get children,
     * because it may not be initialized when you call it
     */
    pathCache: Map<NodePath<Node, Node> | null, Map<Node | null, NodePath<Node, Node>>>;
    scopeCache: Map<NodePath<Node, Node>, Scope>;
    makeScope: boolean;
    shouldValidateNodes: boolean;
    cloneFunction: (node: any) => any;
    private currentSkipPaths;
    private readonly skipPathSetStack;
    /** Store newly added nodes to this queue for traversal */
    private readonly queueStack;
    constructor(options?: TraverseOptions);
    setSkipped(path: NodePath): void;
    setNotSkipped(path: NodePath): void;
    shouldSkip(path: NodePath): boolean;
    private updateCurrentSkipPaths;
    newSkipPathStack(): void;
    restorePrevSkipPathStack(): void;
    pushToQueue(paths: NodePath[], stackName: keyof Context['queueStack'][number]): void;
    newQueue(): void;
    popQueue(): {
        new: NodePath[];
        unSkipped: NodePath[];
    };
}
type Keys<N extends Node> = Exclude<keyof N, keyof BaseNode>;
type PickKeysWithValue<N extends Node, Condition> = {
    [K in keyof N]: N[K] extends Condition ? K : never;
}[keyof N];
type NodePathData<T extends Node, P extends Node> = {
    node: NodePath<T>['node'];
    key: NodePath['key'];
    listKey: NodePath['listKey'];
    parentPath: NodePath<T, P>['parentPath'];
    ctx: Context;
};
export type NodePathT<N extends NodeTypes, P extends NodeTypes | null = null> = NodePath<NodeT<N>, null extends P ? Node : NodeT<Exclude<P, null>>>;
export declare class NodePath<T extends Node = Node, P extends Node = Node> implements NodePathDocs {
    readonly node: T | null;
    readonly type: T['type'] | null;
    key: string | number | null;
    listKey: string | null;
    removed: boolean;
    readonly parentPath: NodePath<P> | null;
    readonly parent: P | null;
    readonly container: P | Node[] | null;
    readonly ctx: Context;
    scope: Scope | undefined | null;
    private constructor();
    /** Get the cached NodePath object or create new if cache is not available */
    static for<T extends Node = Node, P extends Node = Node>(data: NodePathData<T, P>): NodePath<T, P>;
    init(parentScope?: Scope): this;
    protected throwNoParent(methodName: string): never;
    protected assertNotRemoved(): void;
    protected assertNotNull(methodName: string): void;
    get parentKey(): string | null;
    cloneNode(): T | null;
    skip(): void;
    skipChildren(): void;
    unSkip(): void;
    unskip(): void;
    unSkipChildren(): void;
    unskipChildren(): void;
    traverse<S>(visitors: Visitors<S>, state?: S): void;
    findParent<N extends Node>(predicate: (path: NodePath<N>) => boolean): NodePath<N> | null;
    find<N extends Node>(predicate: (path: NodePath<N>) => boolean): NodePath<N> | null;
    getFunctionParent(): NodePath<t.Function> | null;
    getAncestry(): NodePath[];
    isAncestorOf(path: NodePath): boolean;
    isDescendantOf(path: NodePath): boolean;
    protected updateSiblingIndex(fromIndex: number, incrementBy: number): void;
    insertBefore(nodes: readonly Node[]): NodePath<typeof nodes[number], P>[];
    insertAfter(nodes: readonly Node[]): NodePath<typeof nodes[number], P>[];
    unshiftContainer<K extends PickKeysWithValue<T, Node[]>>(listKey: K extends never ? string : K, nodes: Readonly<K extends never ? Node[] : T[K]>): NodePath<K extends never ? Node : T[K] extends Node[] ? T[K][number] : Node, T>[];
    pushContainer<K extends PickKeysWithValue<T, Node[]>>(listKey: K extends never ? string : K, nodes: Readonly<K extends never ? Node[] : T[K]>): NodePath<K extends never ? Node : T[K] extends Node[] ? T[K][number] : Node, T>[];
    get<K extends Keys<T>>(key: K): T[K] extends (infer U | null)[] ? U extends Node ? NodePath<U, T>[] : NodePath<never, T>[] : T[K] extends Node ? NodePath<T[K], T> : NodePath<never, T>;
    get<N extends Node | Node[] | unknown = unknown>(key: string): unknown extends N ? NodePath | NodePath[] : N extends Node[] ? NodePath<N[number]>[] : N extends Node ? NodePath<N> : NodePath<never>;
    getSibling<N extends Node = Node>(key: string | number): NodePath<N> | undefined | never;
    getOpposite(): NodePath<Node, Node> | undefined;
    getPrevSibling(): NodePath | undefined | never;
    getNextSibling(): NodePath | undefined | never;
    getAllPrevSiblings(): NodePath[] | undefined | never;
    getAllNextSiblings(): NodePath[] | undefined | never;
    has(key: Keys<T> extends never ? string : Keys<T>): boolean;
    is(key: Keys<T> extends never ? string : Keys<T>): boolean;
    private onRemove;
    private markRemoved;
    remove(): void;
    replaceWith<N extends Node = Node>(node: N): NodePath<N, P>;
    replaceWithMultiple<N extends readonly Node[]>(nodes: N): NodePath<N[number]>[];
}
export {};
