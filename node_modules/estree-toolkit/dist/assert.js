"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.nullable = exports.oneOf = exports.arrayOf = exports.any = exports.nodeAlias = exports.node = exports.nonNull = exports.validIdentifier = exports.isReserved = exports.value = exports.meaningfulType = exports.OR = exports.chain = exports.runValidation = void 0;
const aliases_1 = require("./aliases");
const runValidation = (validateFn, value) => {
    const errorMsg = validateFn(value);
    if (errorMsg != null) {
        throw new Error(errorMsg);
    }
};
exports.runValidation = runValidation;
const chain = (...validateFns) => (validateFns.reduce((prevFn, fn) => (val) => prevFn(val) || fn(val)));
exports.chain = chain;
const OR = (...validateFns) => (value) => {
    const errorMsgs = [];
    for (let i = 0; i < validateFns.length; i++) {
        const errorMsg = validateFns[i](value);
        if (errorMsg != null) {
            errorMsgs.push(errorMsg);
        }
        else {
            break;
        }
    }
    if (errorMsgs.length === validateFns.length) {
        return `The value is not compatible with the required type.\n\nMessages:\n${errorMsgs.join('\n')}`;
    }
    return null;
};
exports.OR = OR;
/* istanbul ignore next */
const meaningfulType = (value) => {
    if (value === null) {
        return 'null';
    }
    else if (Array.isArray(value)) {
        return 'array';
    }
    else {
        return typeof value;
    }
};
exports.meaningfulType = meaningfulType;
const value = (...types) => {
    if (types.length === 1) {
        const type = types[0];
        return function validate(value) {
            if (typeof value !== type) {
                return `Expected the value to be a \`${type}\` but got a \`${(0, exports.meaningfulType)(value)}\`. The value is ${JSON.stringify(value)}.`;
            }
            return null;
        };
    }
    else {
        return function validate(value) {
            for (let i = 0; i < types.length; i++) {
                const type = types[i];
                if (typeof value === type || (type === 'null' && value === null)) {
                    return null;
                }
            }
            return `Expected the value to be one of \`${JSON.stringify(types)}\` but got a \`${(0, exports.meaningfulType)(value)}\`. The value is ${JSON.stringify(value)}.`;
        };
    }
};
exports.value = value;
const reservedKeywords = new Set(`
do if in for let new try var case else enum
eval false null undefined NaN this true void
with break catch class const super throw while
yield delete export import public return static
switch typeof default extends finally package
private continue debugger function arguments
interface protected implements instanceof
`.trim().split(/[ \n]/).map((s) => s.trim()));
const isReserved = (name) => reservedKeywords.has(name);
exports.isReserved = isReserved;
const validIdentifier = (jsx) => (name) => {
    if ((jsx ? /[\s]/ : /[-\s]/).test(name) ||
        /^\d/.test(name) ||
        name.length === 0) {
        return `${JSON.stringify(name)} is not a valid identifier.`;
    }
    return null;
};
exports.validIdentifier = validIdentifier;
const nonNull = (value) => {
    if (value == null) {
        return 'Expected the value to be non-null but got null or undefined value.';
    }
    return null;
};
exports.nonNull = nonNull;
const node = (...types) => {
    if (types.length === 1) {
        const type = types[0];
        return (value) => {
            if (value == null || value.type !== type) {
                return `Expected a "${type}" node but got a \`${(0, exports.meaningfulType)(value)}\`. The value is ${JSON.stringify(value)}.`;
            }
            return null;
        };
    }
    else {
        return (value) => {
            if (types.indexOf(value.type) === -1) {
                return `Expected one of (${types.join()}) node but got a \`${(0, exports.meaningfulType)(value)}\`. The value is ${JSON.stringify(value)}.`;
            }
            return null;
        };
    }
};
exports.node = node;
const nodeAlias = (alias) => (value) => {
    if (value == null || !(value.type in aliases_1.aliases[alias])) {
        return `Expected one of (${Object.keys(aliases_1.aliases[alias]).join()}) node but got a \`${(0, exports.meaningfulType)(value)}\`. The value is ${JSON.stringify(value)}.`;
    }
    return null;
};
exports.nodeAlias = nodeAlias;
const any = () => null;
exports.any = any;
const arrayOf = (validateFn) => (value) => {
    if (Array.isArray(value)) {
        let errorMsg;
        for (let i = 0; i < value.length; i++) {
            errorMsg = validateFn(value[i]);
            if (errorMsg != null)
                return `Got unexpected value at index ${i}:\n  ${errorMsg}`;
        }
        return null;
    }
    else {
        return `Expected the value to be an array but got a \`${(0, exports.meaningfulType)(value)}\`. The value is ${JSON.stringify(value)}.`;
    }
};
exports.arrayOf = arrayOf;
const oneOf = (items) => (value) => {
    if (!items.includes(value)) {
        return `Expected the value to be one of ${JSON.stringify(items)}, but got ${JSON.stringify(value)}`;
    }
    return null;
};
exports.oneOf = oneOf;
const nullable = (validateFn) => (value) => {
    if (value === null) {
        return null;
    }
    return validateFn(value);
};
exports.nullable = nullable;
