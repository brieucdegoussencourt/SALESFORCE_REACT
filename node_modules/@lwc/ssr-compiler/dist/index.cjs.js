/**
 * Copyright (c) 2024 Salesforce, Inc.
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var astring = require('astring');
var estreeToolkit = require('estree-toolkit');
var meriyah = require('meriyah');
var acorn = require('acorn');
var immer = require('immer');
var templateCompiler = require('@lwc/template-compiler');
var util = require('util');

/**
 * Copyright (c) 2024 Salesforce, Inc.
 */
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
/**
 *
 * @param value
 * @param msg
 */

/*
 * Copyright (c) 2024, Salesforce, Inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const { 
/** Detached {@linkcode Object.assign}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign MDN Reference}. */
assign, 
/** Detached {@linkcode Object.create}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create MDN Reference}. */
create, 
/** Detached {@linkcode Object.defineProperties}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties MDN Reference}. */
defineProperties, 
/** Detached {@linkcode Object.defineProperty}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty MDN Reference}. */
defineProperty, 
/** Detached {@linkcode Object.entries}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries MDN Reference}. */
entries, 
/** Detached {@linkcode Object.freeze}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze MDN Reference}. */
freeze, 
/** Detached {@linkcode Object.getOwnPropertyDescriptor}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor MDN Reference}. */
getOwnPropertyDescriptor, 
/** Detached {@linkcode Object.getOwnPropertyDescriptors}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptors MDN Reference}. */
getOwnPropertyDescriptors, 
/** Detached {@linkcode Object.getOwnPropertyNames}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames MDN Reference}. */
getOwnPropertyNames, 
/** Detached {@linkcode Object.getPrototypeOf}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf MDN Reference}. */
getPrototypeOf, 
/** Detached {@linkcode Object.hasOwnProperty}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty MDN Reference}. */
hasOwnProperty, 
/** Detached {@linkcode Object.isFrozen}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen MDN Reference}. */
isFrozen, 
/** Detached {@linkcode Object.keys}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys MDN Reference}. */
keys, 
/** Detached {@linkcode Object.seal}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/seal MDN Reference}. */
seal, 
/** Detached {@linkcode Object.setPrototypeOf}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf MDN Reference}. */
setPrototypeOf, } = Object;
// For some reason, JSDoc don't get picked up for multiple renamed destructured constants (even
// though it works fine for one, e.g. isArray), so comments for these are added to the export
// statement, rather than this declaration.
const { concat: ArrayConcat, copyWithin: ArrayCopyWithin, every: ArrayEvery, fill: ArrayFill, filter: ArrayFilter, find: ArrayFind, findIndex: ArrayFindIndex, includes: ArrayIncludes, indexOf: ArrayIndexOf, join: ArrayJoin, map: ArrayMap, pop: ArrayPop, push: ArrayPush, reduce: ArrayReduce, reverse: ArrayReverse, shift: ArrayShift, slice: ArraySlice, some: ArraySome, sort: ArraySort, splice: ArraySplice, unshift: ArrayUnshift, forEach, // Weird anomaly!
 } = Array.prototype;
// No JSDocs here - see comment for Array.prototype
const { charAt: StringCharAt, charCodeAt: StringCharCodeAt, replace: StringReplace, split: StringSplit, slice: StringSlice, toLowerCase: StringToLowerCase, } = String.prototype;

/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
/**
 * According to the following list, there are 48 aria attributes of which two (ariaDropEffect and
 * ariaGrabbed) are deprecated:
 * https://www.w3.org/TR/wai-aria-1.1/#x6-6-definitions-of-states-and-properties-all-aria-attributes
 *
 * The above list of 46 aria attributes is consistent with the following resources:
 * https://github.com/w3c/aria/pull/708/files#diff-eacf331f0ffc35d4b482f1d15a887d3bR11060
 * https://wicg.github.io/aom/spec/aria-reflection.html
 *
 * NOTE: If you update this list, please update test files that implicitly reference this list!
 * Searching the codebase for `aria-flowto` and `ariaFlowTo` should be good enough to find all usages.
 */
const AriaPropertyNames = [
    'ariaActiveDescendant',
    'ariaAtomic',
    'ariaAutoComplete',
    'ariaBusy',
    'ariaChecked',
    'ariaColCount',
    'ariaColIndex',
    'ariaColIndexText',
    'ariaColSpan',
    'ariaControls',
    'ariaCurrent',
    'ariaDescribedBy',
    'ariaDescription',
    'ariaDetails',
    'ariaDisabled',
    'ariaErrorMessage',
    'ariaExpanded',
    'ariaFlowTo',
    'ariaHasPopup',
    'ariaHidden',
    'ariaInvalid',
    'ariaKeyShortcuts',
    'ariaLabel',
    'ariaLabelledBy',
    'ariaLevel',
    'ariaLive',
    'ariaModal',
    'ariaMultiLine',
    'ariaMultiSelectable',
    'ariaOrientation',
    'ariaOwns',
    'ariaPlaceholder',
    'ariaPosInSet',
    'ariaPressed',
    'ariaReadOnly',
    'ariaRelevant',
    'ariaRequired',
    'ariaRoleDescription',
    'ariaRowCount',
    'ariaRowIndex',
    'ariaRowIndexText',
    'ariaRowSpan',
    'ariaSelected',
    'ariaSetSize',
    'ariaSort',
    'ariaValueMax',
    'ariaValueMin',
    'ariaValueNow',
    'ariaValueText',
    'ariaBrailleLabel',
    'ariaBrailleRoleDescription',
    'role',
];
const { AriaAttrNameToPropNameMap, AriaPropNameToAttrNameMap } = /*@__PURE__*/ (() => {
    const AriaAttrNameToPropNameMap = create(null);
    const AriaPropNameToAttrNameMap = create(null);
    // Synthetic creation of all AOM property descriptors for Custom Elements
    forEach.call(AriaPropertyNames, (propName) => {
        const attrName = StringToLowerCase.call(StringReplace.call(propName, /^aria/, () => 'aria-'));
        AriaAttrNameToPropNameMap[attrName] = propName;
        AriaPropNameToAttrNameMap[propName] = attrName;
    });
    return { AriaAttrNameToPropNameMap, AriaPropNameToAttrNameMap };
})();

/*
 * Copyright (c) 2024, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const reservedKeywords = new Set([
    'NaN',
    'arguments',
    'break',
    'case',
    'catch',
    'class',
    'const',
    'continue',
    'debugger',
    'default',
    'delete',
    'do',
    'else',
    'enum',
    'eval',
    'export',
    'extends',
    'false',
    'finally',
    'for',
    'function',
    'if',
    'implements',
    'import',
    'in',
    'instanceof',
    'interface',
    'let',
    'new',
    'null',
    'package',
    'private',
    'protected',
    'public',
    'return',
    'static',
    'super',
    'switch',
    'this',
    'throw',
    'true',
    'try',
    'typeof',
    'undefined',
    'var',
    'void',
    'while',
    'with',
    'yield',
]);

/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
// Void elements are elements that self-close even without an explicit solidus (slash),
// e.g. `</tagName>` or `<tagName />`. For instance, `<meta>` closes on its own; no need for a slash.
// These only come from HTML; there are no void elements in the SVG or MathML namespaces.
// See: https://html.spec.whatwg.org/multipage/syntax.html#syntax-tags
const VOID_ELEMENTS = [
    'area',
    'base',
    'br',
    'col',
    'embed',
    'hr',
    'img',
    'input',
    'link',
    'meta',
    'source',
    'track',
    'wbr',
];
// These elements have been deprecated but preserving their usage for backwards compatibility
// until we can officially deprecate them from LWC.
// See: https://html.spec.whatwg.org/multipage/obsolete.html#obsolete-but-conforming-features
const DEPRECATED_VOID_ELEMENTS = ['param', 'keygen', 'menuitem'];
const VOID_ELEMENTS_SET = /*@__PURE__*/ new Set([...VOID_ELEMENTS, ...DEPRECATED_VOID_ELEMENTS]);
/**
 *
 * @param name
 * @param namespace
 */
function isVoidElement(name, namespace) {
    return VOID_ELEMENTS_SET.has(name.toLowerCase());
}
/** version: 6.7.2 */

/*
 * Copyright (c) 2024, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
/**
 * This accomplishes two things:
 *
 *  1. it replaces "lwc" with "@lwc/ssr-runtime" in an import specifier
 *  2. it makes note of the local var name associated with the `LightningElement` import
 */
function replaceLwcImport(path, state) {
    if (!path.node || path.node.source.value !== 'lwc') {
        return;
    }
    for (const specifier of path.node.specifiers) {
        if (specifier.type === 'ImportSpecifier' &&
            specifier.imported.type === 'Identifier' &&
            specifier.imported.name === 'LightningElement') {
            state.lightningElementIdentifier = specifier.local.name;
            break;
        }
    }
    path.replaceWith(estreeToolkit.builders.importDeclaration(path.node.specifiers, estreeToolkit.builders.literal('@lwc/ssr-runtime')));
}

/*
 * Copyright (c) 2024, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
/**
 * While traversing the component JS, this takes note of any .html files that are
 * explicitly imported..
 */
function catalogTmplImport(path, state) {
    if (!path.node) {
        return;
    }
    const { specifiers, source } = path.node;
    const specifier = specifiers[0];
    if (typeof source.value !== 'string' ||
        !source.value.endsWith('.html') ||
        specifiers.length !== 1 ||
        specifier.type !== 'ImportDefaultSpecifier') {
        return;
    }
    state.tmplExplicitImports = state.tmplExplicitImports ?? new Map();
    state.tmplExplicitImports.set(specifier.local.name, source.value);
}

/*
 * Copyright (c) 2024, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const PLACEHOLDER_PREFIX = `__ESTEMPLATE_${Math.random().toString().slice(2)}_PLACEHOLDER__`;
const visitors$1 = {
    Identifier(path, state) {
        if (path.node?.name.startsWith(PLACEHOLDER_PREFIX)) {
            const key = path.node.name.slice(PLACEHOLDER_PREFIX.length);
            const validateReplacement = state.placeholderToValidator.get(key);
            const replacementNode = state.replacementNodes[key];
            if (validateReplacement &&
                !(Array.isArray(replacementNode)
                    ? replacementNode.every(validateReplacement)
                    : validateReplacement(replacementNode))) {
                throw new Error(`Validation failed for templated node of type ${path.node.type}`);
            }
            if (replacementNode === null) {
                path.remove();
            }
            else if (Array.isArray(replacementNode)) {
                if (replacementNode.length === 0) {
                    path.remove();
                }
                else {
                    if (path.parentPath.node.type === 'ExpressionStatement') {
                        path.parentPath.replaceWithMultiple(replacementNode);
                    }
                    else {
                        path.replaceWithMultiple(replacementNode);
                    }
                }
            }
            else {
                path.replaceWith(replacementNode);
            }
        }
    },
    Literal(path, state) {
        if (typeof path.node?.value === 'string' &&
            path.node.value.startsWith(PLACEHOLDER_PREFIX)) {
            const key = path.node.value.slice(PLACEHOLDER_PREFIX.length);
            const validateReplacement = state.placeholderToValidator.get(key);
            const replacementNode = state.replacementNodes[key];
            if (validateReplacement && !validateReplacement(replacementNode)) {
                throw new Error(`Validation failed for templated node of type ${path.node.type}`);
            }
            path.replaceWith(replacementNode);
        }
    },
};
function esTemplateImpl(javascriptSegments, validatorFns, wrap, unwrap) {
    let placeholderCount = 0;
    let parsableCode = javascriptSegments[0];
    validatorFns.reverse();
    const placeholderToValidator = new Map();
    for (const segment of javascriptSegments.slice(1)) {
        const validatorFn = validatorFns.pop();
        if (validatorFn) {
            placeholderToValidator.set(placeholderCount.toString(), validatorFn);
        }
        parsableCode += `${PLACEHOLDER_PREFIX}${placeholderCount++}`;
        parsableCode += segment;
    }
    if (wrap) {
        parsableCode = wrap(parsableCode);
    }
    const originalAstProgram = acorn.parse(parsableCode, {
        ecmaVersion: 2022,
        allowAwaitOutsideFunction: true,
        allowReturnOutsideFunction: true,
        allowSuperOutsideMethod: true,
        allowImportExportEverywhere: true,
        locations: false,
    });
    let originalAst;
    const finalCharacter = javascriptSegments.at(-1)?.trimEnd()?.at(-1);
    if (originalAstProgram.body.length === 1) {
        originalAst =
            finalCharacter === ';' && originalAstProgram.body[0].type === 'ExpressionStatement'
                ? (originalAst = originalAstProgram.body[0].expression)
                : (originalAst = originalAstProgram.body[0]);
    }
    else {
        originalAst = originalAstProgram.body;
    }
    // Turns Acorn AST objects into POJOs, for use with Immer.
    originalAst = JSON.parse(JSON.stringify(originalAst));
    return function templatedAst(...replacementNodes) {
        const result = immer.produce(originalAst, (astDraft) => estreeToolkit.traverse(astDraft, visitors$1, {
            placeholderToValidator,
            replacementNodes,
        }));
        return unwrap ? unwrap(result) : result;
    };
}
function esTemplate(javascriptSegments, ...validatorFns) {
    return esTemplateImpl(javascriptSegments, validatorFns);
}
function esTemplateWithYield(javascriptSegments, ...validatorFns) {
    const wrap = (code) => `function* placeholder() {${code}}`;
    const unwrap = (node) => node.body.body.length === 1 ? node.body.body[0] : node.body.body;
    return esTemplateImpl(javascriptSegments, validatorFns, wrap, unwrap);
}

/*
 * Copyright (c) 2024, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const bDefaultStyleImport = esTemplate `
    import defaultStylesheets from '${estreeToolkit.is.literal}';
`;
function catalogStyleImport(path, state) {
    const specifier = path.node.specifiers[0];
    if (typeof path.node.source.value !== 'string' ||
        !path.node.source.value.endsWith('.css') ||
        path.node.specifiers.length !== 1 ||
        specifier.type !== 'ImportDefaultSpecifier') {
        return;
    }
    state.cssExplicitImports = state.cssExplicitImports ?? new Map();
    state.cssExplicitImports.set(specifier.local.name, path.node.source.value);
}
const componentNamePattern = /[/\\](?<componentName>[a-z_-]+)[/\\]\k<componentName>\.[tj]s$/;
/**
 * This adds implicit style imports to the compiled component artifact.
 */
function addStylesheetImports(ast, state, filepath) {
    const componentName = componentNamePattern.exec(filepath)?.groups?.componentName;
    if (!componentName) {
        throw new Error(`Could not determine component name from file path: ${filepath}`);
    }
    if (state.cssExplicitImports || state.staticStylesheetIds) {
        throw new Error(`Unimplemented static stylesheets, but found:\n${[...state.cssExplicitImports].join('  \n')}`);
    }
    ast.body.unshift(bDefaultStyleImport(estreeToolkit.builders.literal(`./${componentName}.css`)));
}
function catalogStaticStylesheets(ids, state) {
    state.staticStylesheetIds = state.staticStylesheetIds ?? new Set();
    for (const id of ids) {
        state.staticStylesheetIds.add(id);
    }
}

/*
 * Copyright (c) 2024, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const isStringLiteral = (node) => estreeToolkit.is.literal(node) && typeof node.value === 'string';
const isIdentOrRenderCall = (node) => estreeToolkit.is.identifier(node) ||
    (estreeToolkit.is.callExpression(node) &&
        estreeToolkit.is.memberExpression(node.callee) &&
        estreeToolkit.is.identifier(node.callee.property) &&
        node.callee.property.name === 'render');
function isNullableOf(validator) {
    return (node) => node === null || (validator && validator(node));
}

/*
 * Copyright (c) 2024, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const bImportDeclaration = esTemplate `
    import ${estreeToolkit.is.identifier} from "${isStringLiteral}";
`;

/*
 * Copyright (c) 2024, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const bGenerateMarkup = esTemplate `
    export async function* generateMarkup(tagName, props, attrs, slotted) {
        attrs = attrs ?? {};
        ${isNullableOf(estreeToolkit.is.expressionStatement)};
        const instance = new ${estreeToolkit.is.identifier}({
            tagName: tagName.toUpperCase(),
        });
        instance.__internal__setState(props, __REFLECTED_PROPS__, attrs);
        instance.isConnected = true;
        instance.connectedCallback?.();
        yield \`<\${tagName}\`;
        yield *__renderAttrs(attrs)
        yield '>';
        const tmplFn = ${isIdentOrRenderCall} ?? __fallbackTmpl;
        yield* tmplFn(props, attrs, slotted, ${estreeToolkit.is.identifier}, instance, defaultStylesheets);
        yield \`</\${tagName}>\`;
    }
`;
const bInsertFallbackTmplImport = esTemplate `
    import { fallbackTmpl as __fallbackTmpl, renderAttrs as __renderAttrs } from '@lwc/ssr-runtime';
`;
const bCreateReflectedPropArr = esTemplate `
    const __REFLECTED_PROPS__ = ${estreeToolkit.is.arrayExpression};
`;
function bReflectedAttrsObj(reflectedPropNames) {
    // This will build getter properties for each reflected property. It'll look
    // something like this:
    //
    //   get ['aria-checked']() {
    //      return props.ariaChecked;
    //   }
    //
    // The props object will be kept up-to-date with any new values set on the corresponding
    // property name in the component instance.
    const reflectedAttrGetters = reflectedPropNames.map((propName) => estreeToolkit.builders.property('get', estreeToolkit.builders.literal(AriaPropNameToAttrNameMap[propName]), estreeToolkit.builders.functionExpression(null, [], estreeToolkit.builders.blockStatement([
        estreeToolkit.builders.returnStatement(estreeToolkit.builders.memberExpression(estreeToolkit.builders.identifier('props'), estreeToolkit.builders.identifier(propName))),
    ]))));
    // This mutates the `attrs` object, adding the reflected aria attributes that have been
    // detected. Example:
    //
    //   attrs = {
    //     ...attrs,
    //     get ['aria-checked']() {
    //       return props.ariaChecked;
    //     }
    //   }
    return estreeToolkit.builders.expressionStatement(estreeToolkit.builders.assignmentExpression('=', estreeToolkit.builders.identifier('attrs'), estreeToolkit.builders.objectExpression([estreeToolkit.builders.spreadElement(estreeToolkit.builders.identifier('attrs')), ...reflectedAttrGetters])));
}
/**
 * This builds a generator function `generateMarkup` and adds it to the component JS's
 * compilation output. `generateMarkup` acts as the glue between component JS and its
 * template(s), including:
 *
 *  - managing reflection of attrs & props
 *  - instantiating the component instance
 *  - setting the internal state of that component instance
 *  - invoking component lifecycle methods
 *  - yielding the tag name & attributes
 *  - deferring to the template function for yielding child content
 */
function addGenerateMarkupExport(program, state, filename) {
    const { hasRenderMethod, tmplExplicitImports } = state;
    const classIdentifier = estreeToolkit.builders.identifier(state.lwcClassName);
    const renderCall = hasRenderMethod
        ? estreeToolkit.builders.callExpression(estreeToolkit.builders.memberExpression(estreeToolkit.builders.identifier('instance'), estreeToolkit.builders.identifier('render')), [])
        : estreeToolkit.builders.identifier('tmpl');
    if (!tmplExplicitImports) {
        const defaultTmplPath = filename.replace(/\.js$/, '.html');
        program.body.unshift(bImportDeclaration(estreeToolkit.builders.identifier('tmpl'), estreeToolkit.builders.literal(defaultTmplPath)));
    }
    let attrsAugmentation = null;
    if (state.reflectedPropsInPlay.size) {
        attrsAugmentation = bReflectedAttrsObj([...state.reflectedPropsInPlay]);
    }
    const reflectedPropArr = estreeToolkit.builders.arrayExpression([...state.reflectedPropsInPlay].map((propName) => estreeToolkit.builders.literal(propName)));
    program.body.unshift(bInsertFallbackTmplImport());
    program.body.push(bCreateReflectedPropArr(reflectedPropArr));
    program.body.push(bGenerateMarkup(attrsAugmentation, classIdentifier, renderCall, classIdentifier));
}

/*
 * Copyright (c) 2024, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const visitors = {
    $: { scope: true },
    Identifier(path, state) {
        const reflectedAttrName = AriaPropNameToAttrNameMap[path.node.name];
        if (reflectedAttrName) {
            state.reflectedPropsInPlay.add(path.node.name);
        }
    },
    ImportDeclaration(path, state) {
        if (!path.node || !path.node.source.value || typeof path.node.source.value !== 'string') {
            return;
        }
        replaceLwcImport(path, state);
        catalogTmplImport(path, state);
        catalogStyleImport(path, state);
    },
    ClassDeclaration(path, state) {
        if (!path.node?.superClass) {
            return;
        }
        if (path.node.superClass.type === 'Identifier' &&
            // It is possible to inherit from something that inherits from
            // LightningElement, so the detection here needs additional work.
            path.node.superClass.name === 'LightningElement') {
            state.isLWC = true;
            if (path.node.id) {
                state.lwcClassName = path.node.id.name;
            }
            else {
                path.node.id = estreeToolkit.builders.identifier('DefaultComponentName');
                state.lwcClassName = 'DefaultComponentName';
            }
        }
    },
    PropertyDefinition(path, state) {
        if (path.node &&
            path.node.static &&
            estreeToolkit.is.identifier(path.node.key) &&
            path.node.key.name === 'stylesheets' &&
            estreeToolkit.is.arrayExpression(path.node.value) &&
            path.node.value.elements.every((el) => estreeToolkit.is.identifier(el))) {
            catalogStaticStylesheets(path.node.value.elements.map((el) => el.name), state);
        }
    },
    MethodDefinition(path, state) {
        if (path.node?.key.type !== 'Identifier') {
            return;
        }
        switch (path.node.key.name) {
            case 'constructor':
                path.node.value.params = [estreeToolkit.builders.identifier('propsAvailableAtConstruction')];
                break;
            case 'connectedCallback':
                state.hasConnectedCallback = true;
                break;
            case 'render':
                state.hasRenderMethod = true;
                break;
            case 'renderedCallback':
                state.hadRenderedCallback = true;
                path.remove();
                break;
            case 'disconnectedCallback':
                state.hadDisconnectedCallback = true;
                path.remove();
                break;
            case 'errorCallback':
                state.hadErrorCallback = true;
                path.remove();
                break;
        }
    },
    Super(path, _state) {
        const parentFn = path.getFunctionParent();
        if (parentFn &&
            parentFn.parentPath?.node?.type === 'MethodDefinition' &&
            parentFn.parentPath?.node?.kind === 'constructor' &&
            path.parentPath &&
            path.parentPath.node?.type === 'CallExpression') {
            path.parentPath.node.arguments = [estreeToolkit.builders.identifier('propsAvailableAtConstruction')];
        }
    },
};
function compileJS(src, filename) {
    const ast = meriyah.parseModule(src, {
        module: true,
        next: true,
    });
    const state = {
        isLWC: false,
        hasConstructor: false,
        hasConnectedCallback: false,
        hasRenderMethod: false,
        hadRenderedCallback: false,
        hadDisconnectedCallback: false,
        hadErrorCallback: false,
        lightningElementIdentifier: null,
        lwcClassName: null,
        tmplExplicitImports: null,
        cssExplicitImports: null,
        staticStylesheetIds: null,
        reflectedPropsInPlay: new Set(),
    };
    estreeToolkit.traverse(ast, visitors, state);
    if (!state.isLWC) {
        // If an `extends LightningElement` is not detected in the JS, the
        // file in question is likely not an LWC. With this v1 implementation,
        // we'll just return the original source.
        return {
            code: src,
        };
    }
    addGenerateMarkupExport(ast, state, filename);
    addStylesheetImports(ast, state, filename);
    return {
        code: astring.generate(ast, {}),
    };
}

/*
 * Copyright (c) 2024, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const Comment = function Comment(node, cxt) {
    if (cxt.templateOptions.preserveComments) {
        return [estreeToolkit.builders.expressionStatement(estreeToolkit.builders.yieldExpression(estreeToolkit.builders.literal(`<!--${node.value}-->`)))];
    }
    else {
        return [];
    }
};

/*
 * Copyright (c) 2024, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const bImportHtmlEscape = esTemplate `
    import { htmlEscape } from '@lwc/shared';
`;
const importHtmlEscapeKey = 'import:htmlEscape';
function cleanStyleAttrVal(styleAttrVal) {
    if (styleAttrVal.endsWith(';')) {
        styleAttrVal = styleAttrVal.slice(0, -1);
    }
    return styleAttrVal.trim();
}
// This is a mostly-correct regular expression will only match if the entire string
// provided is a valid ECMAScript identifier. Its imperfections lie in the fact that
// it will match strings like "export" when "export" is actually a reserved keyword
// and therefore not a valid identifier. When combined with a check against reserved
// keywords, it is a reliable test for whether a provided string is a valid identifier.
const imperfectIdentifierMatcher = /^[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*$/;
const isValidIdentifier = (str) => !reservedKeywords.has(str) && imperfectIdentifierMatcher.test(str);
function optimizeAdjacentYieldStmts(statements) {
    let prevStmt = null;
    return statements
        .map((stmt) => {
        if (
        // Check if the current statement and previous statement are
        // both yield expression statements that yield a string literal.
        prevStmt &&
            estreeToolkit.is.expressionStatement(prevStmt) &&
            estreeToolkit.is.yieldExpression(prevStmt.expression) &&
            !prevStmt.expression.delegate &&
            prevStmt.expression.argument &&
            estreeToolkit.is.literal(prevStmt.expression.argument) &&
            typeof prevStmt.expression.argument.value === 'string' &&
            estreeToolkit.is.expressionStatement(stmt) &&
            estreeToolkit.is.yieldExpression(stmt.expression) &&
            !stmt.expression.delegate &&
            stmt.expression.argument &&
            estreeToolkit.is.literal(stmt.expression.argument) &&
            typeof stmt.expression.argument.value === 'string') {
            prevStmt.expression.argument.value += stmt.expression.argument.value;
            return null;
        }
        prevStmt = stmt;
        return stmt;
    })
        .filter((el) => el !== null);
}

/*
 * Copyright (c) 2024, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
function getRootMemberExpression$1(node) {
    return node.object.type === 'MemberExpression' ? getRootMemberExpression$1(node.object) : node;
}
function expressionIrToEs(node, cxt) {
    if (node.type === 'Identifier') {
        const isLocalVar = cxt.isLocalVar(node.name);
        return isLocalVar
            ? node
            : estreeToolkit.builders.memberExpression(estreeToolkit.builders.identifier('instance'), node);
    }
    else if (node.type === 'MemberExpression') {
        const nodeClone = structuredClone(node);
        const rootMemberExpr = getRootMemberExpression$1(nodeClone);
        if (!cxt.isLocalVar(rootMemberExpr.object.name)) {
            rootMemberExpr.object = estreeToolkit.builders.memberExpression(estreeToolkit.builders.identifier('instance'), rootMemberExpr.object);
        }
        return nodeClone;
    }
    throw new Error(`Unimplemented expression: ${node.type}`);
}

/*
 * Copyright (c) 2024, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const bYieldFromChildGenerator = esTemplateWithYield `
    {
        const childProps = ${estreeToolkit.is.objectExpression};
        const childAttrs = ${estreeToolkit.is.objectExpression};
        const childSlottedContentGenerators = {};
        yield* ${estreeToolkit.is.identifier}(${estreeToolkit.is.literal}, childProps, childAttrs, childSlottedContentGenerators);
    }
`;
const bImportGenerateMarkup = (localName, importPath) => estreeToolkit.builders.importDeclaration([estreeToolkit.builders.importSpecifier(estreeToolkit.builders.identifier('generateMarkup'), estreeToolkit.builders.identifier(localName))], estreeToolkit.builders.literal(importPath));
function getChildAttrsOrProps(attrs, cxt) {
    const objectAttrsOrProps = attrs.map((attr) => {
        const key = isValidIdentifier(attr.name) ? estreeToolkit.builders.identifier(attr.name) : estreeToolkit.builders.literal(attr.name);
        if (attr.value.type === 'Literal' && typeof attr.value.value === 'string') {
            const value = attr.name === 'style' ? cleanStyleAttrVal(attr.value.value) : attr.value.value;
            return estreeToolkit.builders.property('init', key, estreeToolkit.builders.literal(value));
        }
        else if (attr.value.type === 'Literal' && typeof attr.value.value === 'boolean') {
            return estreeToolkit.builders.property('init', key, estreeToolkit.builders.literal(attr.value.value));
        }
        else if (attr.value.type === 'Identifier' || attr.value.type === 'MemberExpression') {
            const propValue = expressionIrToEs(attr.value, cxt);
            return estreeToolkit.builders.property('init', key, propValue);
        }
        throw new Error(`Unimplemented child attr IR node type: ${attr.value.type}`);
    });
    return estreeToolkit.builders.objectExpression(objectAttrsOrProps);
}
function reflectAriaPropsAsAttrs(props) {
    return props
        .map((prop) => {
        if (prop.attributeName.startsWith('aria-') || prop.attributeName === 'role') {
            return {
                type: 'Attribute',
                name: prop.attributeName,
                value: prop.value,
            };
        }
        return null;
    })
        .filter((el) => el !== null);
}
const Component = function Component(node, cxt) {
    // Import the custom component's generateMarkup export.
    const childGeneratorLocalName = `generateMarkup_${templateCompiler.toPropertyName(node.name)}`;
    const importPath = templateCompiler.kebabcaseToCamelcase(node.name);
    const componentImport = bImportGenerateMarkup(childGeneratorLocalName, importPath);
    cxt.hoist(componentImport, childGeneratorLocalName);
    const childTagName = node.name;
    const attributes = [...node.attributes, ...reflectAriaPropsAsAttrs(node.properties)];
    return [
        bYieldFromChildGenerator(getChildAttrsOrProps(node.properties, cxt), getChildAttrsOrProps(attributes, cxt), estreeToolkit.builders.identifier(childGeneratorLocalName), estreeToolkit.builders.literal(childTagName)),
    ];
};

/*
 * Copyright (c) 2024, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const bYield$1 = (expr) => estreeToolkit.builders.expressionStatement(estreeToolkit.builders.yieldExpression(expr));
const bConditionalLiveYield = esTemplateWithYield `
    {
        const attrOrPropValue = ${estreeToolkit.is.expression};
        const valueType = typeof attrOrPropValue;
        if (attrOrPropValue && (valueType === 'string' || valueType === 'boolean')) {
            yield ' ' + ${estreeToolkit.is.literal};
            if (valueType === 'string') {
                yield '="' + htmlEscape(attrOrPropValue, true) + '"';
            }
        }
    }
`;
function yieldAttrOrPropLiteralValue(name, valueNode) {
    const { value, type } = valueNode;
    if (typeof value === 'string') {
        const yieldedValue = name === 'style' ? cleanStyleAttrVal(value) : value;
        return [bYield$1(estreeToolkit.builders.literal(` ${name}="${yieldedValue}"`))];
    }
    else if (typeof value === 'boolean') {
        return [bYield$1(estreeToolkit.builders.literal(` ${name}`))];
    }
    throw new Error(`Unknown attr/prop literal: ${type}`);
}
function yieldAttrOrPropLiveValue(name, value) {
    const instanceMemberRef = estreeToolkit.builders.memberExpression(estreeToolkit.builders.identifier('instance'), value);
    return [bConditionalLiveYield(instanceMemberRef, estreeToolkit.builders.literal(name))];
}
function reorderAttributes(attrs, props) {
    let classAttr = null;
    let styleAttr = null;
    let slotAttr = null;
    const boringAttrs = attrs.filter((attr) => {
        if (attr.name === 'class') {
            classAttr = attr;
            return false;
        }
        else if (attr.name === 'style') {
            styleAttr = attr;
            return false;
        }
        else if (attr.name === 'slot') {
            slotAttr = attr;
            return false;
        }
        return true;
    });
    return [classAttr, styleAttr, ...boringAttrs, ...props, slotAttr].filter((el) => el !== null);
}
const Element = function Element(node, cxt) {
    const attrsAndProps = reorderAttributes(node.attributes, node.properties);
    const yieldAttrsAndProps = attrsAndProps.flatMap((attr) => {
        cxt.hoist(bImportHtmlEscape(), importHtmlEscapeKey);
        if (attr.value.type === 'Literal') {
            return yieldAttrOrPropLiteralValue(attr.name, attr.value);
        }
        else {
            return yieldAttrOrPropLiveValue(attr.name, attr.value);
        }
    });
    if (isVoidElement(node.name)) {
        return [bYield$1(estreeToolkit.builders.literal(`<${node.name}`)), ...yieldAttrsAndProps, bYield$1(estreeToolkit.builders.literal(`>`))];
    }
    return [
        bYield$1(estreeToolkit.builders.literal(`<${node.name}`)),
        ...yieldAttrsAndProps,
        bYield$1(estreeToolkit.builders.literal(`>`)),
        ...irChildrenToEs(node.children, cxt),
        bYield$1(estreeToolkit.builders.literal(`</${node.name}>`)),
    ].filter(Boolean);
};

/*
 * Copyright (c) 2024, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
function getRootMemberExpression(node) {
    return node.object.type === 'MemberExpression' ? getRootMemberExpression(node.object) : node;
}
function getRootIdentifier(node) {
    const rootMemberExpression = getRootMemberExpression(node);
    return estreeToolkit.is.identifier(rootMemberExpression?.object) ? rootMemberExpression.object : null;
}
const bForOfYieldFrom = esTemplate `
    for (let [${estreeToolkit.is.identifier}, ${estreeToolkit.is.identifier}] of Object.entries(${estreeToolkit.is.expression} ?? {})) {
        ${estreeToolkit.is.statement};
    }
`;
const ForEach = function ForEach(node, cxt) {
    const forItemId = node.item.name;
    const forIndexId = node.index?.name ?? '__unused__';
    cxt.pushLocalVars([forItemId, forIndexId]);
    const forEachStatements = node.children.flatMap((childNode) => {
        return irToEs(childNode, cxt);
    });
    cxt.popLocalVars();
    const expression = node.expression;
    const scopeReferencedId = estreeToolkit.is.memberExpression(expression)
        ? getRootIdentifier(expression)
        : null;
    const iterable = cxt.isLocalVar(scopeReferencedId?.name)
        ? node.expression
        : estreeToolkit.builders.memberExpression(estreeToolkit.builders.identifier('instance'), node.expression);
    return [
        bForOfYieldFrom(estreeToolkit.builders.identifier(forIndexId), estreeToolkit.builders.identifier(forItemId), iterable, optimizeAdjacentYieldStmts(forEachStatements)),
    ];
};

/*
 * Copyright (c) 2024, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
function bBlockStatement(childNodes, cxt) {
    return estreeToolkit.builders.blockStatement(optimizeAdjacentYieldStmts(childNodes.flatMap((childNode) => irToEs(childNode, cxt))));
}
const If = function If(node, cxt) {
    const { modifier: trueOrFalseAsStr, condition, children } = node;
    const trueOrFalse = trueOrFalseAsStr === 'true';
    const comparison = estreeToolkit.builders.binaryExpression('===', estreeToolkit.builders.literal(trueOrFalse), expressionIrToEs(condition, cxt));
    return [estreeToolkit.builders.ifStatement(comparison, bBlockStatement(children, cxt))];
};
function bIfStatement(ifElseIfNode, cxt) {
    const { children, condition, else: elseNode } = ifElseIfNode;
    let elseBlock = null;
    if (elseNode) {
        if (elseNode.type === 'ElseBlock') {
            elseBlock = bBlockStatement(elseNode.children, cxt);
        }
        else {
            elseBlock = bIfStatement(elseNode, cxt);
        }
    }
    return estreeToolkit.builders.ifStatement(expressionIrToEs(condition, cxt), bBlockStatement(children, cxt), elseBlock);
}
const IfBlock = function IfBlock(node, cxt) {
    return [bIfStatement(node, cxt)];
};

/*
 * Copyright (c) 2024, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const bYield = (expr) => estreeToolkit.builders.expressionStatement(estreeToolkit.builders.yieldExpression(expr));
const bYieldEscapedString = esTemplateWithYield `
    const ${estreeToolkit.is.identifier} = ${estreeToolkit.is.expression};
    if (typeof ${estreeToolkit.is.identifier} === 'string') {
        yield (${estreeToolkit.is.literal} && ${estreeToolkit.is.identifier} === '') ? '\\u200D' : htmlEscape(${estreeToolkit.is.identifier});
    } else if (typeof ${estreeToolkit.is.identifier} === 'number') {
        yield ${estreeToolkit.is.identifier}.toString();
    } else {
        yield htmlEscape((${estreeToolkit.is.identifier} ?? '').toString());
    }
`;
function isLiteral(node) {
    return node.type === 'Literal';
}
const Text = function Text(node, cxt) {
    if (isLiteral(node.value)) {
        return [bYield(estreeToolkit.builders.literal(node.value.value))];
    }
    const isIsolatedTextNode = estreeToolkit.builders.literal((!cxt.prevSibling || cxt.prevSibling.type !== 'Text') &&
        (!cxt.nextSibling || cxt.nextSibling.type !== 'Text'));
    const valueToYield = expressionIrToEs(node.value, cxt);
    cxt.hoist(bImportHtmlEscape(), importHtmlEscapeKey);
    const tempVariable = estreeToolkit.builders.identifier(cxt.getUniqueVar());
    return bYieldEscapedString(tempVariable, valueToYield, tempVariable, isIsolatedTextNode, tempVariable, tempVariable, tempVariable, tempVariable, tempVariable);
};

/*
 * Copyright (c) 2024, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const identifierChars = 'abcdefghijklmnopqrstuvwxyz';
function genId(n, prevChars = '') {
    const remaining = Math.floor(n / identifierChars.length);
    const result = identifierChars.charAt(n % identifierChars.length) + prevChars;
    return remaining <= 0 ? result : genId(remaining - 1, result);
}
function* genIds() {
    let counter = 0;
    while (true) {
        yield genId(counter++);
    }
}
function createNewContext(templateOptions) {
    const hoisted = new Map();
    const hoist = (stmt, dedupeKey) => hoisted.set(dedupeKey, stmt);
    const localVarStack = [];
    const pushLocalVars = (vars) => {
        localVarStack.push(new Set(vars));
    };
    const popLocalVars = () => {
        localVarStack.pop();
    };
    const isLocalVar = (varName) => {
        if (!varName) {
            return false;
        }
        for (const stackFrame of localVarStack) {
            if (stackFrame.has(varName)) {
                return true;
            }
        }
        return false;
    };
    const uniqueVarGenerator = genIds();
    const getUniqueVar = () => uniqueVarGenerator.next().value;
    return {
        hoisted,
        cxt: {
            hoist,
            pushLocalVars,
            popLocalVars,
            isLocalVar,
            getUniqueVar,
            templateOptions,
        },
    };
}

/*
 * Copyright (c) 2024, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const Root = function Root(node, cxt) {
    return irChildrenToEs(node.children, cxt);
};
const transformers = {
    Comment: Comment,
    Component: Component,
    Root: Root,
    Text: Text,
    Element: Element,
    ForEach: ForEach,
    If: If,
    IfBlock: IfBlock,
};
const defaultTransformer = (node) => {
    throw new Error(`Unimplemented IR node: ${util.inspect(node)}`);
};
function irChildrenToEs(children, cxt) {
    const result = children.flatMap((child, idx) => {
        cxt.prevSibling = children[idx - 1];
        cxt.nextSibling = children[idx + 1];
        return irToEs(child, cxt);
    });
    cxt.prevSibling = undefined;
    cxt.nextSibling = undefined;
    return result;
}
function irToEs(node, cxt) {
    const transformer = transformers[node.type] ?? defaultTransformer;
    return transformer(node, cxt);
}
function templateIrToEsTree(node, contextOpts) {
    const { hoisted, cxt } = createNewContext(contextOpts);
    const statements = irToEs(node, cxt);
    return {
        hoisted: hoisted.values(),
        statements,
    };
}

/*
 * Copyright (c) 2024, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const isBool = (node) => estreeToolkit.is.literal(node) && typeof node.value === 'boolean';
const bExportTemplate = esTemplate `
    export default async function* tmpl(props, attrs, slotted, Cmp, instance, stylesheets) {
        if (!${isBool} && Cmp.renderMode !== 'light') {
            yield \`<template shadowrootmode="open"\${Cmp.delegatesFocus ? ' shadowrootdelegatesfocus' : ''}>\`
        }

        for (const stylesheet of stylesheets ?? []) {
            // TODO
            const token = null;
            const useActualHostSelector = true;
            const useNativeDirPseudoclass = null;
            yield '<style type="text/css">';
            yield stylesheet(token, useActualHostSelector, useNativeDirPseudoclass);
            yield '</style>';
        }

        ${estreeToolkit.is.statement};

        if (!${isBool} && Cmp.renderMode !== 'light') {
            yield '</template>'
        }
    }
`;
function compileTemplate(src, _filename) {
    const { root, warnings } = templateCompiler.parse(src);
    if (!root || warnings.length) {
        for (const warning of warnings) {
            // eslint-disable-next-line no-console
            console.error('Cannot compile:', warning.message);
        }
        throw new Error('Template compilation failure; see warnings in the console.');
    }
    const tmplRenderMode = root.directives.find((directive) => directive.name === 'RenderMode')?.value?.value ??
        'shadow';
    const astShadowModeBool = tmplRenderMode === 'light' ? estreeToolkit.builders.literal(true) : estreeToolkit.builders.literal(false);
    const preserveComments = !!root.directives.find((directive) => directive.name === 'PreserveComments')?.value?.value;
    const { hoisted, statements } = templateIrToEsTree(root, { preserveComments });
    const moduleBody = [
        ...hoisted,
        bExportTemplate(astShadowModeBool, optimizeAdjacentYieldStmts(statements), astShadowModeBool),
    ];
    const program = estreeToolkit.builders.program(moduleBody, 'module');
    return {
        code: astring.generate(program, {}),
    };
}

/*
 * Copyright (c) 2024, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
function compileComponentForSSR(src, filename, _options) {
    const { code } = compileJS(src, filename);
    return { code, map: undefined };
}
function compileTemplateForSSR(src, filename, _options) {
    const { code } = compileTemplate(src);
    return { code, map: undefined };
}

exports.compileComponentForSSR = compileComponentForSSR;
exports.compileTemplateForSSR = compileTemplateForSSR;
/** version: 6.7.2 */
//# sourceMappingURL=index.cjs.js.map
