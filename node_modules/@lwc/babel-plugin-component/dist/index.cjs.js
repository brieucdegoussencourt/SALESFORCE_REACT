/**
 * Copyright (c) 2024 Salesforce, Inc.
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var path = require('path');
var helperModuleImports = require('@babel/helper-module-imports');
var shared = require('@lwc/shared');
var errors = require('@lwc/errors');
var lineColumn = require('line-column');

/*
 * Copyright (c) 2023, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
// This set is for attributes that have a camel cased property name
// For example, div.tabIndex.
// We do not want users to define @api properties with these names
// Because the template will never call them. It'll always call the camel
// cased version.
const AMBIGUOUS_PROP_SET = new Map([
    ['bgcolor', 'bgColor'],
    ['accesskey', 'accessKey'],
    ['contenteditable', 'contentEditable'],
    ['contextmenu', 'contextMenu'],
    ['tabindex', 'tabIndex'],
    ['maxlength', 'maxLength'],
    ['maxvalue', 'maxValue'],
]);
// This set is for attributes that can never be defined
// by users on their components.
// We throw for these.
const DISALLOWED_PROP_SET = new Set(['is', 'class', 'slot', 'style']);
const LWC_PACKAGE_ALIAS = 'lwc';
const LWC_PACKAGE_EXPORTS = {
    BASE_COMPONENT: 'LightningElement',
    API_DECORATOR: 'api',
    TRACK_DECORATOR: 'track',
    WIRE_DECORATOR: 'wire',
};
const LWC_COMPONENT_PROPERTIES = {
    PUBLIC_PROPS: 'publicProps',
    PUBLIC_METHODS: 'publicMethods',
    WIRE: 'wire',
    TRACK: 'track',
};
const DECORATOR_TYPES = {
    PROPERTY: 'property',
    GETTER: 'getter',
    SETTER: 'setter',
    METHOD: 'method',
};
const REGISTER_COMPONENT_ID = 'registerComponent';
const REGISTER_DECORATORS_ID = 'registerDecorators';
const TEMPLATE_KEY = 'tmpl';
const COMPONENT_NAME_KEY = 'sel';
const API_VERSION_KEY = 'apiVersion';
const COMPONENT_CLASS_ID = '__lwc_component_class_internal';

/*
 * Copyright (c) 2023, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
function getBaseName(classPath) {
    const ext = path.extname(classPath);
    return path.basename(classPath, ext);
}
function importDefaultTemplate(path, state) {
    const { filename } = state.file.opts;
    const componentName = getBaseName(filename);
    return helperModuleImports.addDefault(path, `./${componentName}.html`, {
        nameHint: TEMPLATE_KEY,
    });
}
function needsComponentRegistration(path) {
    return ((path.isIdentifier() && path.node.name !== 'undefined' && path.node.name !== 'null') ||
        path.isCallExpression() ||
        path.isClassDeclaration() ||
        path.isConditionalExpression());
}
function getComponentRegisteredName(t, state) {
    const { namespace, name } = state.opts;
    const kebabCasedName = name?.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
    const componentName = namespace && kebabCasedName ? `${namespace}-${kebabCasedName}` : '';
    return t.stringLiteral(componentName);
}
function component ({ types: t }) {
    function createRegisterComponent(declarationPath, state) {
        const registerComponentId = helperModuleImports.addNamed(declarationPath, REGISTER_COMPONENT_ID, LWC_PACKAGE_ALIAS);
        const templateIdentifier = importDefaultTemplate(declarationPath, state);
        const statementPath = declarationPath.getStatementParent();
        const componentRegisteredName = getComponentRegisteredName(t, state);
        let node = declarationPath.node;
        if (declarationPath.isClassDeclaration()) {
            const hasIdentifier = t.isIdentifier(node.id);
            if (hasIdentifier) {
                statementPath.insertBefore(node);
                node = node.id;
            }
            else {
                // if it does not have an id, we can treat it as a ClassExpression
                t.toExpression(node);
            }
        }
        const apiVersion = shared.getAPIVersionFromNumber(state.opts.apiVersion);
        // Example:
        //     registerComponent(cmp, {
        //       tmpl: template,
        //       sel: 'x-foo',
        //       apiVersion: '58'
        //     })
        const registerComponentExpression = t.callExpression(registerComponentId, [
            node,
            t.objectExpression([
                t.objectProperty(t.identifier(TEMPLATE_KEY), templateIdentifier),
                t.objectProperty(t.identifier(COMPONENT_NAME_KEY), componentRegisteredName),
                // It's important that, at this point, we have an APIVersion rather than just a number.
                // The client needs to trust the server that it's providing an actual known API version
                t.objectProperty(t.identifier(API_VERSION_KEY), t.numericLiteral(apiVersion)),
            ]),
        ]);
        // Example:
        // const __lwc_component_class_internal = registerComponent(cmp, ...);
        // This provides a way to access the component class for other lwc tools
        const classIdentifier = t.identifier(COMPONENT_CLASS_ID);
        declarationPath.parentPath.insertBefore(t.variableDeclaration('const', [
            t.variableDeclarator(classIdentifier, registerComponentExpression),
        ]));
        return classIdentifier;
    }
    return {
        ExportDefaultDeclaration(path, state) {
            const implicitResolution = !state.opts.isExplicitImport;
            if (implicitResolution) {
                const declaration = path.get('declaration');
                if (needsComponentRegistration(declaration)) {
                    declaration.replaceWith(createRegisterComponent(declaration, state));
                }
            }
        },
    };
}

/*
 * Copyright (c) 2023, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
function isClassMethod(classMethod, properties = {}) {
    const { kind = 'method', name } = properties;
    return (classMethod.isClassMethod({ kind }) &&
        (!name || classMethod.get('key').isIdentifier({ name })) &&
        (properties.static === undefined || classMethod.node.static === properties.static));
}
function isGetterClassMethod(classMethod, properties = {}) {
    return isClassMethod(classMethod, {
        kind: 'get',
        name: properties.name,
        static: properties.static,
    });
}
function isSetterClassMethod(classMethod, properties = {}) {
    return isClassMethod(classMethod, {
        kind: 'set',
        name: properties.name,
        static: properties.static,
    });
}
function getEngineImportsStatements(path) {
    const programPath = path.isProgram()
        ? path
        : path.findParent((node) => node.isProgram());
    return programPath.get('body').filter((node) => {
        const source = node.get('source');
        return node.isImportDeclaration() && source.isStringLiteral({ value: LWC_PACKAGE_ALIAS });
    });
}
function getEngineImportSpecifiers(path) {
    const imports = getEngineImportsStatements(path);
    return (imports
        // Flat-map the specifier list for each import statement
        .flatMap((importStatement) => importStatement.get('specifiers'))
        // Skip ImportDefaultSpecifier and ImportNamespaceSpecifier
        .filter((specifier) => specifier.type === 'ImportSpecifier')
        // Get the list of specifiers with their name
        .map((specifier) => {
        const imported = specifier.get('imported').node
            .name;
        return { name: imported, path: specifier };
    }));
}
function normalizeLocation(source) {
    const location = (source.node && (source.node.loc || source.node._loc)) || null;
    if (!location) {
        return null;
    }
    const code = source.hub.getCode();
    if (!code) {
        return {
            line: location.start.line,
            column: location.start.column,
        };
    }
    const lineFinder = lineColumn(code);
    const startOffset = lineFinder.toIndex(location.start.line, location.start.column + 1);
    const endOffset = lineFinder.toIndex(location.end.line, location.end.column) + 1;
    const length = endOffset - startOffset;
    return {
        line: location.start.line,
        column: location.start.column,
        start: startOffset,
        length,
    };
}
function generateError(source, { errorInfo, messageArgs }, state) {
    const message = errors.generateErrorMessage(errorInfo, messageArgs);
    const error = source.buildCodeFrameError(message);
    error.filename = state.filename;
    error.loc = normalizeLocation(source);
    error.lwcCode = errorInfo && errorInfo.code;
    return error;
}
function incrementMetricCounter(metric, state) {
    state.opts.instrumentation?.incrementCounter(metric);
}

/*
 * Copyright (c) 2023, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const { API_DECORATOR: API_DECORATOR$2 } = LWC_PACKAGE_EXPORTS;
function isApiDecorator(decorator) {
    return decorator.name === API_DECORATOR$2;
}

/*
 * Copyright (c) 2023, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const { TRACK_DECORATOR: TRACK_DECORATOR$2 } = LWC_PACKAGE_EXPORTS;
function validateConflict(path, decorators, state) {
    const isPublicFieldTracked = decorators.some((decorator) => decorator.name === TRACK_DECORATOR$2 &&
        decorator.path.parentPath.node === path.parentPath.node);
    if (isPublicFieldTracked) {
        throw generateError(path, {
            errorInfo: errors.DecoratorErrors.API_AND_TRACK_DECORATOR_CONFLICT,
        }, state);
    }
}
function isBooleanPropDefaultTrue(property) {
    const propertyValue = property.node.value;
    return propertyValue && propertyValue.type === 'BooleanLiteral' && propertyValue.value;
}
function validatePropertyValue(property, state) {
    if (isBooleanPropDefaultTrue(property)) {
        throw generateError(property, {
            errorInfo: errors.DecoratorErrors.INVALID_BOOLEAN_PUBLIC_PROPERTY,
        }, state);
    }
}
function validatePropertyName(property, state) {
    if (property.node.computed) {
        throw generateError(property, {
            errorInfo: errors.DecoratorErrors.PROPERTY_CANNOT_BE_COMPUTED,
        }, state);
    }
    const propertyName = property.get('key.name').node;
    if (propertyName === 'part') {
        throw generateError(property, {
            errorInfo: errors.DecoratorErrors.PROPERTY_NAME_PART_IS_RESERVED,
            messageArgs: [propertyName],
        }, state);
    }
    else if (propertyName.startsWith('on')) {
        throw generateError(property, {
            errorInfo: errors.DecoratorErrors.PROPERTY_NAME_CANNOT_START_WITH_ON,
            messageArgs: [propertyName],
        }, state);
    }
    else if (propertyName.startsWith('data') && propertyName.length > 4) {
        throw generateError(property, {
            errorInfo: errors.DecoratorErrors.PROPERTY_NAME_CANNOT_START_WITH_DATA,
            messageArgs: [propertyName],
        }, state);
    }
    else if (DISALLOWED_PROP_SET.has(propertyName)) {
        throw generateError(property, {
            errorInfo: errors.DecoratorErrors.PROPERTY_NAME_IS_RESERVED,
            messageArgs: [propertyName],
        }, state);
    }
    else if (AMBIGUOUS_PROP_SET.has(propertyName)) {
        const camelCased = AMBIGUOUS_PROP_SET.get(propertyName);
        throw generateError(property, {
            errorInfo: errors.DecoratorErrors.PROPERTY_NAME_IS_AMBIGUOUS,
            messageArgs: [propertyName, camelCased],
        }, state);
    }
}
function validateSingleApiDecoratorOnSetterGetterPair(decorators, state) {
    // keep track of visited class methods
    const visitedMethods = new Set();
    decorators.forEach((decorator) => {
        const { path, decoratedNodeType } = decorator;
        // since we are validating get/set we only look at @api methods
        if (isApiDecorator(decorator) &&
            (decoratedNodeType === DECORATOR_TYPES.GETTER ||
                decoratedNodeType === DECORATOR_TYPES.SETTER)) {
            const methodPath = path.parentPath;
            const methodName = methodPath.get('key.name').node;
            if (visitedMethods.has(methodName)) {
                throw generateError(methodPath, {
                    errorInfo: errors.DecoratorErrors.SINGLE_DECORATOR_ON_SETTER_GETTER_PAIR,
                    messageArgs: [methodName],
                }, state);
            }
            visitedMethods.add(methodName);
        }
    });
}
function validateUniqueness(decorators, state) {
    const apiDecorators = decorators.filter(isApiDecorator);
    for (let i = 0; i < apiDecorators.length; i++) {
        const { path: currentPath, type: currentType } = apiDecorators[i];
        const currentPropertyName = currentPath.parentPath.get('key.name').node;
        for (let j = 0; j < apiDecorators.length; j++) {
            const { path: comparePath, type: compareType } = apiDecorators[j];
            const comparePropertyName = comparePath.parentPath.get('key.name')
                .node;
            // We will throw if the considered properties have the same name, and when their
            // are not part of a pair of getter/setter.
            const haveSameName = currentPropertyName === comparePropertyName;
            const isDifferentProperty = currentPath !== comparePath;
            const isGetterSetterPair = (currentType === DECORATOR_TYPES.GETTER &&
                compareType === DECORATOR_TYPES.SETTER) ||
                (currentType === DECORATOR_TYPES.SETTER && compareType === DECORATOR_TYPES.GETTER);
            if (haveSameName && isDifferentProperty && !isGetterSetterPair) {
                throw generateError(comparePath, {
                    errorInfo: errors.DecoratorErrors.DUPLICATE_API_PROPERTY,
                    messageArgs: [currentPropertyName],
                }, state);
            }
        }
    }
}
function validate$3(decorators, state) {
    const apiDecorators = decorators.filter(isApiDecorator);
    if (apiDecorators.length === 0) {
        return;
    }
    apiDecorators.forEach(({ path, decoratedNodeType }) => {
        validateConflict(path, decorators, state);
        if (decoratedNodeType !== DECORATOR_TYPES.METHOD) {
            const property = path.parentPath;
            validatePropertyName(property, state);
            validatePropertyValue(property, state);
        }
    });
    validateSingleApiDecoratorOnSetterGetterPair(decorators, state);
    validateUniqueness(decorators, state);
}

const { PUBLIC_PROPS, PUBLIC_METHODS } = LWC_COMPONENT_PROPERTIES;
const PUBLIC_PROP_BIT_MASK = {
    PROPERTY: 0,
    GETTER: 1,
    SETTER: 2,
};
function getPropertyBitmask(type) {
    switch (type) {
        case DECORATOR_TYPES.GETTER:
            return PUBLIC_PROP_BIT_MASK.GETTER;
        case DECORATOR_TYPES.SETTER:
            return PUBLIC_PROP_BIT_MASK.SETTER;
        default:
            return PUBLIC_PROP_BIT_MASK.PROPERTY;
    }
}
function getSiblingGetSetPairType(propertyName, type, classBodyItems) {
    const siblingKind = type === DECORATOR_TYPES.GETTER ? 'set' : 'get';
    const siblingNode = classBodyItems.find((classBodyItem) => {
        const isClassMethod = classBodyItem.isClassMethod({ kind: siblingKind });
        const isSamePropertyName = classBodyItem.node.key.name ===
            propertyName;
        return isClassMethod && isSamePropertyName;
    });
    if (siblingNode) {
        return siblingKind === 'get' ? DECORATOR_TYPES.GETTER : DECORATOR_TYPES.SETTER;
    }
}
function computePublicPropsConfig(publicPropertyMetas, classBodyItems) {
    return publicPropertyMetas.reduce((acc, { propertyName, decoratedNodeType }) => {
        if (!(propertyName in acc)) {
            acc[propertyName] = {};
        }
        acc[propertyName].config |= getPropertyBitmask(decoratedNodeType);
        if (decoratedNodeType === DECORATOR_TYPES.GETTER ||
            decoratedNodeType === DECORATOR_TYPES.SETTER) {
            // With the latest decorator spec, only one of the getter/setter pair needs a decorator.
            // We need to add the proper bitmask for the sibling getter/setter if it exists.
            const pairType = getSiblingGetSetPairType(propertyName, decoratedNodeType, classBodyItems);
            if (pairType) {
                acc[propertyName].config |= getPropertyBitmask(pairType);
            }
        }
        return acc;
    }, {});
}
function transform$2(t, decoratorMetas, classBodyItems) {
    const objectProperties = [];
    const apiDecoratorMetas = decoratorMetas.filter(isApiDecorator);
    const publicPropertyMetas = apiDecoratorMetas.filter(({ decoratedNodeType }) => decoratedNodeType !== DECORATOR_TYPES.METHOD);
    if (publicPropertyMetas.length) {
        const propsConfig = computePublicPropsConfig(publicPropertyMetas, classBodyItems);
        objectProperties.push(t.objectProperty(t.identifier(PUBLIC_PROPS), t.valueToNode(propsConfig)));
    }
    const publicMethodMetas = apiDecoratorMetas.filter(({ decoratedNodeType }) => decoratedNodeType === DECORATOR_TYPES.METHOD);
    if (publicMethodMetas.length) {
        const methodNames = publicMethodMetas.map(({ propertyName }) => propertyName);
        objectProperties.push(t.objectProperty(t.identifier(PUBLIC_METHODS), t.valueToNode(methodNames)));
    }
    return objectProperties;
}

/*
 * Copyright (c) 2023, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const { API_DECORATOR: API_DECORATOR$1 } = LWC_PACKAGE_EXPORTS;
var api = {
    name: API_DECORATOR$1,
    validate: validate$3,
    transform: transform$2,
};

/*
 * Copyright (c) 2023, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const { WIRE_DECORATOR: WIRE_DECORATOR$2 } = LWC_PACKAGE_EXPORTS;
function isWireDecorator(decorator) {
    return decorator.name === WIRE_DECORATOR$2;
}

const { TRACK_DECORATOR: TRACK_DECORATOR$1, WIRE_DECORATOR: WIRE_DECORATOR$1, API_DECORATOR } = LWC_PACKAGE_EXPORTS;
function validateWireId(id, path, state) {
    if (!id) {
        throw generateError(path, {
            errorInfo: errors.DecoratorErrors.ADAPTER_SHOULD_BE_FIRST_PARAMETER,
        }, state);
    }
    const isMemberExpression = id.isMemberExpression();
    if (!id.isIdentifier() && !isMemberExpression) {
        throw generateError(id, {
            errorInfo: errors.DecoratorErrors.FUNCTION_IDENTIFIER_SHOULD_BE_FIRST_PARAMETER,
        }, state);
    }
    if (id.isMemberExpression({ computed: true })) {
        throw generateError(id, {
            errorInfo: errors.DecoratorErrors.FUNCTION_IDENTIFIER_CANNOT_HAVE_COMPUTED_PROPS,
        }, state);
    }
    // TODO [#3444]: improve member expression computed typechecking
    // @ts-expect-error type narrowing incorrectly reduces id to `never`
    if (isMemberExpression && !id.get('object').isIdentifier()) {
        throw generateError(id, {
            errorInfo: errors.DecoratorErrors.FUNCTION_IDENTIFIER_CANNOT_HAVE_NESTED_MEMBER_EXRESSIONS,
        }, state);
    }
    // TODO [#3444]: improve member expression computed typechecking
    // Ensure wire adapter is imported (check for member expression or identifier)
    // @ts-expect-error type narrowing incorrectly reduces id to `never`
    const wireBinding = isMemberExpression ? id.node.object.name : id.node.name;
    if (!path.scope.getBinding(wireBinding)) {
        throw generateError(id, {
            errorInfo: errors.DecoratorErrors.WIRE_ADAPTER_SHOULD_BE_IMPORTED,
            messageArgs: [id.node.name],
        }, state);
    }
    // ensure wire adapter is a first parameter
    if (wireBinding &&
        !path.scope.getBinding(wireBinding).path.isImportSpecifier() &&
        !path.scope.getBinding(wireBinding).path.isImportDefaultSpecifier()) {
        throw generateError(id, {
            errorInfo: errors.DecoratorErrors.IMPORTED_FUNCTION_IDENTIFIER_SHOULD_BE_FIRST_PARAMETER,
        }, state);
    }
}
function validateWireConfig(config, path, state) {
    if (!config.isObjectExpression()) {
        throw generateError(config, {
            errorInfo: errors.DecoratorErrors.CONFIG_OBJECT_SHOULD_BE_SECOND_PARAMETER,
        }, state);
    }
    for (const prop of config.get('properties')) {
        // Only validate {[computed]: true} object properties; {static: true} props are all valid
        // and we ignore {...spreads} and {methods(){}}
        if (!prop.isObjectProperty() || !prop.node.computed)
            continue;
        const key = prop.get('key');
        if (key.isIdentifier()) {
            // Only allow identifiers that originated from a `const` declaration
            const binding = key.scope.getBinding(key.node.name);
            // TODO [#3956]: Investigate allowing imported constants
            if (binding?.kind === 'const')
                continue;
            // By default, the identifier `undefined` has no binding (when it's actually undefined),
            // but has a binding if it's used as a variable (e.g. `let undefined = "don't do this"`)
            if (key.node.name === 'undefined' && !binding)
                continue;
        }
        else if (key.isLiteral()) {
            // A literal can be a regexp, template literal, or primitive; only allow primitives
            if (key.isTemplateLiteral()) {
                // A template literal is not guaranteed to always result in the same value
                // (e.g. `${Math.random()}`), so we disallow them entirely.
                // TODO [#3956]: Investigate allowing template literals
                throw generateError(key, {
                    errorInfo: errors.DecoratorErrors.COMPUTED_PROPERTY_CANNOT_BE_TEMPLATE_LITERAL,
                }, state);
            }
            else if (!key.isRegExpLiteral()) {
                continue;
            }
        }
        throw generateError(key, {
            errorInfo: errors.DecoratorErrors.COMPUTED_PROPERTY_MUST_BE_CONSTANT_OR_LITERAL,
        }, state);
    }
}
function validateWireParameters(path, state) {
    const expressionArguments = path.get('expression.arguments');
    if (Array.isArray(expressionArguments)) {
        // Multiple arguments: should be [id, config?]
        const [id, config] = expressionArguments;
        validateWireId(id, path, state);
        if (config)
            validateWireConfig(config, path, state);
    }
    else {
        // Single argument: should just be id
        validateWireId(expressionArguments, path, state);
    }
}
function validateUsageWithOtherDecorators(path, decorators, state) {
    decorators.forEach((decorator) => {
        if (path !== decorator.path &&
            decorator.name === WIRE_DECORATOR$1 &&
            decorator.path.parentPath.node === path.parentPath.node) {
            throw generateError(path, {
                errorInfo: errors.DecoratorErrors.ONE_WIRE_DECORATOR_ALLOWED,
            }, state);
        }
        if ((decorator.name === API_DECORATOR || decorator.name === TRACK_DECORATOR$1) &&
            decorator.path.parentPath.node === path.parentPath.node) {
            throw generateError(path, {
                errorInfo: errors.DecoratorErrors.CONFLICT_WITH_ANOTHER_DECORATOR,
                messageArgs: [decorator.name],
            }, state);
        }
    });
}
function validate$2(decorators, state) {
    decorators.filter(isWireDecorator).forEach(({ path }) => {
        validateUsageWithOtherDecorators(path, decorators, state);
        validateWireParameters(path, state);
    });
}

const WIRE_PARAM_PREFIX = '$';
const WIRE_CONFIG_ARG_NAME = '$cmp';
function isObservedProperty(configProperty) {
    const propertyValue = configProperty.get('value');
    return (propertyValue.isStringLiteral() && propertyValue.node.value.startsWith(WIRE_PARAM_PREFIX));
}
function getWiredStatic(wireConfig) {
    return wireConfig
        .get('properties')
        .filter((property) => !isObservedProperty(property))
        .map((path) => path.node);
}
function getWiredParams(t, wireConfig) {
    return wireConfig
        .get('properties')
        .filter((property) => isObservedProperty(property))
        .map((path) => {
        // Need to clone deep the observed property to remove the param prefix
        const clonedProperty = t.cloneNode(path.node);
        clonedProperty.value.value = clonedProperty.value.value.slice(1);
        return clonedProperty;
    });
}
function getGeneratedConfig(t, wiredValue) {
    let counter = 0;
    const configBlockBody = [];
    const configProps = [];
    const generateParameterConfigValue = (memberExprPaths) => {
        // Note: When memberExprPaths ($foo.bar) has an invalid identifier (eg: foo..bar, foo.bar[3])
        //       it should (ideally) resolve in a compilation error during validation phase.
        //       This is not possible due that platform components may have a param definition which is invalid
        //       but passes compilation, and throwing at compile time would break such components.
        //       In such cases where the param does not have proper notation, the config generated will use the bracket
        //       notation to match the current behavior (that most likely end up resolving that param as undefined).
        const isInvalidMemberExpr = memberExprPaths.some((maybeIdentifier) => !(t.isValidES3Identifier(maybeIdentifier) && maybeIdentifier.length > 0));
        const memberExprPropertyGen = !isInvalidMemberExpr
            ? t.identifier
            : t.StringLiteral;
        if (memberExprPaths.length === 1) {
            return {
                configValueExpression: t.memberExpression(t.identifier(WIRE_CONFIG_ARG_NAME), memberExprPropertyGen(memberExprPaths[0])),
            };
        }
        const varName = 'v' + ++counter;
        const varDeclaration = t.variableDeclaration('let', [
            t.variableDeclarator(t.identifier(varName), t.memberExpression(t.identifier(WIRE_CONFIG_ARG_NAME), memberExprPropertyGen(memberExprPaths[0]), isInvalidMemberExpr)),
        ]);
        // Results in: v != null && ... (v = v.i) != null && ... (v = v.(n-1)) != null
        let conditionTest = t.binaryExpression('!=', t.identifier(varName), t.nullLiteral());
        for (let i = 1, n = memberExprPaths.length; i < n - 1; i++) {
            const nextPropValue = t.assignmentExpression('=', t.identifier(varName), t.memberExpression(t.identifier(varName), memberExprPropertyGen(memberExprPaths[i]), isInvalidMemberExpr));
            conditionTest = t.logicalExpression('&&', conditionTest, t.binaryExpression('!=', nextPropValue, t.nullLiteral()));
        }
        // conditionTest ? v.n : undefined
        const configValueExpression = t.conditionalExpression(conditionTest, t.memberExpression(t.identifier(varName), memberExprPropertyGen(memberExprPaths[memberExprPaths.length - 1]), isInvalidMemberExpr), t.identifier('undefined'));
        return {
            varDeclaration,
            configValueExpression,
        };
    };
    if (wiredValue.static) {
        Array.prototype.push.apply(configProps, wiredValue.static);
    }
    if (wiredValue.params) {
        wiredValue.params.forEach((param) => {
            const memberExprPaths = param.value.value.split('.');
            const paramConfigValue = generateParameterConfigValue(memberExprPaths);
            configProps.push(t.objectProperty(param.key, paramConfigValue.configValueExpression, param.computed));
            if (paramConfigValue.varDeclaration) {
                configBlockBody.push(paramConfigValue.varDeclaration);
            }
        });
    }
    configBlockBody.push(t.returnStatement(t.objectExpression(configProps)));
    const fnExpression = t.functionExpression(null, [t.identifier(WIRE_CONFIG_ARG_NAME)], t.blockStatement(configBlockBody));
    return t.objectProperty(t.identifier('config'), fnExpression);
}
function buildWireConfigValue(t, wiredValues) {
    return t.objectExpression(wiredValues.map((wiredValue) => {
        const wireConfig = [];
        if (wiredValue.adapter) {
            wireConfig.push(t.objectProperty(t.identifier('adapter'), wiredValue.adapter.expression));
        }
        if (wiredValue.params) {
            const dynamicParamNames = wiredValue.params.map((p) => {
                if (t.isIdentifier(p.key)) {
                    return p.computed ? t.identifier(p.key.name) : t.stringLiteral(p.key.name);
                }
                else if (t.isLiteral(p.key) &&
                    // Template literals may contain expressions, so they are not allowed
                    !t.isTemplateLiteral(p.key) &&
                    // RegExp are not primitives, so they are not allowed
                    !t.isRegExpLiteral(p.key)) {
                    const value = t.isNullLiteral(p.key) ? null : p.key.value;
                    return t.stringLiteral(String(value));
                }
                // If it's not an identifier or primitive literal then it's a computed expression
                throw new TypeError(`Expected object property key to be an identifier or a literal, but instead saw "${p.key.type}".`);
            });
            wireConfig.push(t.objectProperty(t.identifier('dynamic'), t.arrayExpression(dynamicParamNames)));
        }
        if (wiredValue.isClassMethod) {
            wireConfig.push(t.objectProperty(t.identifier('method'), t.numericLiteral(1)));
        }
        wireConfig.push(getGeneratedConfig(t, wiredValue));
        return t.objectProperty(t.identifier(wiredValue.propertyName), t.objectExpression(wireConfig));
    }));
}
const SUPPORTED_VALUE_TO_TYPE_MAP = {
    StringLiteral: 'string',
    NumericLiteral: 'number',
    BooleanLiteral: 'boolean',
};
const scopedReferenceLookup = (scope) => (name) => {
    const binding = scope.getBinding(name);
    let type;
    let value;
    if (binding) {
        if (binding.kind === 'module') {
            // Resolves module import to the name of the module imported
            // e.g. import { foo } from 'bar' gives value 'bar' for `name == 'foo'
            const parentPathNode = binding.path.parentPath.node;
            if (parentPathNode && parentPathNode.source) {
                type = 'module';
                value = parentPathNode.source.value;
            }
        }
        else if (binding.kind === 'const') {
            // Resolves `const foo = 'text';` references to value 'text', where `name == 'foo'`
            const init = binding.path.node.init;
            if (init &&
                SUPPORTED_VALUE_TO_TYPE_MAP[init.type]) {
                type =
                    SUPPORTED_VALUE_TO_TYPE_MAP[init.type];
                value = init
                    .value;
            }
        }
    }
    return {
        type,
        value,
    };
};
function transform$1(t, decoratorMetas) {
    const objectProperties = [];
    const wiredValues = decoratorMetas.filter(isWireDecorator).map(({ path }) => {
        const [id, config] = path.get('expression.arguments');
        const propertyName = path.parentPath.get('key.name').node;
        const isClassMethod = path.parentPath.isClassMethod({
            kind: 'method',
        });
        const wiredValue = {
            propertyName,
            isClassMethod,
        };
        if (config) {
            wiredValue.static = getWiredStatic(config);
            wiredValue.params = getWiredParams(t, config);
        }
        const referenceLookup = scopedReferenceLookup(path.scope);
        const isMemberExpression = id.isMemberExpression();
        const isIdentifier = id.isIdentifier();
        if (isIdentifier || isMemberExpression) {
            const referenceName = isMemberExpression ? id.node.object.name : id.node.name;
            const reference = referenceLookup(referenceName);
            wiredValue.adapter = {
                name: referenceName,
                expression: t.cloneNode(id.node),
                reference: reference.type === 'module' ? reference.value : undefined,
            };
        }
        return wiredValue;
    });
    if (wiredValues.length) {
        objectProperties.push(t.objectProperty(t.identifier(LWC_COMPONENT_PROPERTIES.WIRE), buildWireConfigValue(t, wiredValues)));
    }
    return objectProperties;
}

/*
 * Copyright (c) 2023, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const { WIRE_DECORATOR } = LWC_PACKAGE_EXPORTS;
var wire = {
    name: WIRE_DECORATOR,
    validate: validate$2,
    transform: transform$1,
};

/*
 * Copyright (c) 2023, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const { TRACK_DECORATOR } = LWC_PACKAGE_EXPORTS;
const TRACK_PROPERTY_VALUE = 1;
function isTrackDecorator(decorator) {
    return decorator.name === TRACK_DECORATOR;
}
function validate$1(decorators, state) {
    decorators.filter(isTrackDecorator).forEach(({ path }) => {
        if (!path.parentPath.isClassProperty()) {
            throw generateError(path, {
                errorInfo: errors.DecoratorErrors.TRACK_ONLY_ALLOWED_ON_CLASS_PROPERTIES,
            }, state);
        }
    });
}
function transform(t, decoratorMetas) {
    const objectProperties = [];
    const trackDecoratorMetas = decoratorMetas.filter(isTrackDecorator);
    if (trackDecoratorMetas.length) {
        const config = trackDecoratorMetas.reduce((acc, meta) => {
            acc[meta.propertyName] = TRACK_PROPERTY_VALUE;
            return acc;
        }, {});
        objectProperties.push(t.objectProperty(t.identifier(LWC_COMPONENT_PROPERTIES.TRACK), t.valueToNode(config)));
    }
    return objectProperties;
}
var track = {
    name: TRACK_DECORATOR,
    transform,
    validate: validate$1,
};

const DECORATOR_TRANSFORMS = [api, wire, track];
const AVAILABLE_DECORATORS = DECORATOR_TRANSFORMS.map((transform) => transform.name).join(', ');
function isLwcDecoratorName(name) {
    return DECORATOR_TRANSFORMS.some((transform) => transform.name === name);
}
/**
 * Returns a list of all the references to an identifier
 * @param identifier
 */
function getReferences(identifier) {
    return identifier.scope.getBinding(identifier.node.name).referencePaths;
}
/**
 * Returns the type of decorator depdending on the property or method if get applied to
 * @param decoratorPath
 * @param state
 */
function getDecoratedNodeType(decoratorPath, state) {
    const propertyOrMethod = decoratorPath.parentPath;
    if (isClassMethod(propertyOrMethod)) {
        return DECORATOR_TYPES.METHOD;
    }
    else if (isGetterClassMethod(propertyOrMethod)) {
        return DECORATOR_TYPES.GETTER;
    }
    else if (isSetterClassMethod(propertyOrMethod)) {
        return DECORATOR_TYPES.SETTER;
    }
    else if (propertyOrMethod.isClassProperty()) {
        return DECORATOR_TYPES.PROPERTY;
    }
    else {
        throw generateError(propertyOrMethod, {
            errorInfo: errors.DecoratorErrors.INVALID_DECORATOR_TYPE,
        }, state);
    }
}
function validateImportedLwcDecoratorUsage(engineImportSpecifiers, state) {
    engineImportSpecifiers
        .filter(({ name }) => isLwcDecoratorName(name))
        .reduce((acc, { name, path }) => {
        // Get a list of all the  local references
        const local = path.get('imported');
        const references = getReferences(local).map((reference) => ({
            name,
            reference,
        }));
        return [...acc, ...references];
    }, [])
        .forEach(({ name, reference }) => {
        // Get the decorator from the identifier
        // If the the decorator is:
        //   - an identifier @track : the decorator is the parent of the identifier
        //   - a call expression @wire("foo") : the decorator is the grand-parent of the identifier
        const decorator = reference.parentPath.isDecorator()
            ? reference.parentPath
            : reference.parentPath.parentPath;
        if (!decorator.isDecorator()) {
            throw generateError(decorator, {
                errorInfo: errors.DecoratorErrors.IS_NOT_DECORATOR,
                messageArgs: [name],
            }, state);
        }
        const propertyOrMethod = decorator.parentPath;
        if (!propertyOrMethod.isClassProperty() && !propertyOrMethod.isClassMethod()) {
            throw generateError(propertyOrMethod, {
                errorInfo: errors.DecoratorErrors.IS_NOT_CLASS_PROPERTY_OR_CLASS_METHOD,
                messageArgs: [name],
            }, state);
        }
    });
}
function isImportedFromLwcSource(decoratorBinding) {
    const bindingPath = decoratorBinding.path;
    return (bindingPath.isImportSpecifier() &&
        bindingPath.parent.source.value === 'lwc');
}
/**
 * Validate the usage of decorator by calling each validation function
 * @param decorators
 * @param state
 */
function validate(decorators, state) {
    for (const { name, path } of decorators) {
        const binding = path.scope.getBinding(name);
        if (binding === undefined || !isImportedFromLwcSource(binding)) {
            throw generateInvalidDecoratorError(path, state);
        }
    }
    DECORATOR_TRANSFORMS.forEach(({ validate }) => validate(decorators, state));
}
/**
 * Remove import specifiers. It also removes the import statement if the specifier list becomes empty
 * @param engineImportSpecifiers
 */
function removeImportedDecoratorSpecifiers(engineImportSpecifiers) {
    engineImportSpecifiers
        .filter(({ name }) => isLwcDecoratorName(name))
        .forEach(({ path }) => {
        const importStatement = path.parentPath;
        path.remove();
        if (importStatement.get('specifiers').length === 0) {
            importStatement.remove();
        }
    });
}
function generateInvalidDecoratorError(path, state) {
    const expressionPath = path.get('expression');
    const { node } = path;
    const { expression } = node;
    let name;
    if (expressionPath.isIdentifier()) {
        name = expression.name;
    }
    else if (expressionPath.isCallExpression()) {
        name = expression.callee.name;
    }
    if (name) {
        return generateError(path.parentPath, {
            errorInfo: errors.DecoratorErrors.INVALID_DECORATOR_WITH_NAME,
            messageArgs: [name, AVAILABLE_DECORATORS, LWC_PACKAGE_ALIAS],
        }, state);
    }
    else {
        return generateError(path.parentPath, {
            errorInfo: errors.DecoratorErrors.INVALID_DECORATOR,
            messageArgs: [AVAILABLE_DECORATORS, LWC_PACKAGE_ALIAS],
        }, state);
    }
}
function collectDecoratorPaths(bodyItems) {
    return bodyItems.reduce((acc, bodyItem) => {
        const decorators = bodyItem.get('decorators');
        if (decorators && decorators.length) {
            acc.push(...decorators);
        }
        return acc;
    }, []);
}
function getDecoratorMetadata(decoratorPath, state) {
    const expressionPath = decoratorPath.get('expression');
    let name;
    if (expressionPath.isIdentifier()) {
        name = expressionPath.node.name;
    }
    else if (expressionPath.isCallExpression()) {
        name = expressionPath.node.callee.name;
    }
    else {
        throw generateInvalidDecoratorError(decoratorPath, state);
    }
    const propertyName = decoratorPath.parent.key.name;
    const decoratedNodeType = getDecoratedNodeType(decoratorPath, state);
    return {
        name,
        propertyName,
        path: decoratorPath,
        decoratedNodeType,
    };
}
function getMetadataObjectPropertyList(t, decoratorMetas, classBodyItems) {
    const list = [
        ...api.transform(t, decoratorMetas, classBodyItems),
        ...track.transform(t, decoratorMetas),
        ...wire.transform(t, decoratorMetas),
    ];
    const fieldNames = classBodyItems
        .filter((field) => field.isClassProperty({ computed: false, static: false }))
        .filter((field) => !field.node.decorators)
        .map((field) => field.node.key.name);
    if (fieldNames.length) {
        list.push(t.objectProperty(t.identifier('fields'), t.valueToNode(fieldNames)));
    }
    return list;
}
function decorators({ types: t }) {
    function createRegisterDecoratorsCallExpression(path, classExpression, props) {
        const id = helperModuleImports.addNamed(path, REGISTER_DECORATORS_ID, LWC_PACKAGE_ALIAS);
        return t.callExpression(id, [classExpression, t.objectExpression(props)]);
    }
    // Babel reinvokes visitors for node reinsertion so we use this to avoid an infinite loop.
    const visitedClasses = new WeakSet();
    return {
        Class(path, state) {
            const { node } = path;
            if (visitedClasses.has(node)) {
                return;
            }
            visitedClasses.add(node);
            const classBodyItems = path.get('body.body');
            if (classBodyItems.length === 0) {
                return;
            }
            if (node.superClass === null &&
                shared.isAPIFeatureEnabled(4 /* APIFeature.SKIP_UNNECESSARY_REGISTER_DECORATORS */, shared.getAPIVersionFromNumber(state.opts.apiVersion))) {
                // Any class exposing a field *must* extend either LightningElement or some other superclass.
                // Even in the case of superclasses and mixins that expose fields, those must extend something as well.
                // So we can skip classes without a superclass to avoid adding unnecessary registerDecorators calls.
                // However, we only do this in later API versions to avoid a breaking change.
                return;
            }
            const decoratorPaths = collectDecoratorPaths(classBodyItems);
            const decoratorMetas = decoratorPaths.map((path) => getDecoratorMetadata(path, state));
            validate(decoratorMetas, state);
            const metaPropertyList = getMetadataObjectPropertyList(t, decoratorMetas, classBodyItems);
            if (metaPropertyList.length === 0) {
                return;
            }
            decoratorPaths.forEach((path) => path.remove());
            const isAnonymousClassDeclaration = path.isClassDeclaration() && !path.get('id').isIdentifier();
            const shouldTransformAsClassExpression = path.isClassExpression() || isAnonymousClassDeclaration;
            if (shouldTransformAsClassExpression) {
                // Example:
                //      export default class extends LightningElement {}
                // Output:
                //      export default registerDecorators(class extends LightningElement {});
                // if it does not have an id, we can treat it as a ClassExpression
                const classExpression = t.toExpression(node);
                path.replaceWith(createRegisterDecoratorsCallExpression(path, classExpression, metaPropertyList));
            }
            else {
                // Example: export default class NamedClass extends LightningElement {}
                // Output:
                //      export default class NamedClass extends LightningElement {}
                //      registerDecorators(NamedClass);
                // Note: This will be further transformed
                const statementPath = path.getStatementParent();
                statementPath.insertAfter(t.expressionStatement(createRegisterDecoratorsCallExpression(path, node.id, metaPropertyList)));
            }
        },
    };
}

/*
 * Copyright (c) 2023, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
function defaultImport(t, specifiers) {
    const defaultImport = specifiers.find((s) => t.isImportDefaultSpecifier(s));
    return defaultImport && defaultImport.local.name;
}
function dedupeImports ({ types: t }) {
    return function (path) {
        const body = path.get('body');
        const importStatements = body.filter((s) => s.isImportDeclaration());
        const visited = new Map();
        importStatements.forEach((importPath) => {
            const sourceLiteral = importPath.node.source;
            // If the import is of the type import * as X, just ignore it since we can't dedupe
            if (importPath.node.specifiers.some((_) => t.isImportNamespaceSpecifier(_))) {
                return;
            }
            // If we have seen the same source, we will try to dedupe it
            if (visited.has(sourceLiteral.value)) {
                const visitedImport = visited.get(sourceLiteral.value);
                const visitedSpecifiers = visitedImport.node.specifiers;
                const visitedDefaultImport = defaultImport(t, visitedSpecifiers);
                // We merge all the named imports unless is a default with the same name
                let canImportBeRemoved = true;
                importPath.node.specifiers.forEach((s) => {
                    if (visitedDefaultImport && t.isImportDefaultSpecifier(s)) {
                        if (visitedDefaultImport !== s.local.name) {
                            canImportBeRemoved = false;
                        }
                    }
                    else {
                        visitedSpecifiers.push(s);
                    }
                });
                if (canImportBeRemoved) {
                    importPath.remove();
                }
                // We need to sort the imports due to a bug in babel where default must be first
                visitedSpecifiers.sort((a) => (t.isImportDefaultSpecifier(a) ? -1 : 1));
            }
            else {
                visited.set(sourceLiteral.value, importPath);
            }
        });
    };
}

function getImportSource(path) {
    return path.parentPath.get('arguments.0');
}
function validateImport(sourcePath, state) {
    if (!sourcePath.isStringLiteral()) {
        throw generateError(sourcePath, {
            errorInfo: errors.LWCClassErrors.INVALID_DYNAMIC_IMPORT_SOURCE_STRICT,
            messageArgs: [String(sourcePath)],
        }, state);
    }
}
/**
 * Expected API for this plugin:
 * { dynamicImports: { loader: string, strictSpecifier: boolean } }
 */
function dynamicImports () {
    function getLoaderRef(path, loaderName, state) {
        if (!state.loaderRef) {
            state.loaderRef = helperModuleImports.addNamed(path, 'load', loaderName);
        }
        return state.loaderRef;
    }
    function addDynamicImportDependency(dependency, state) {
        // TODO [#3444]: state.dynamicImports seems unused and can probably be deleted
        if (!state.dynamicImports) {
            state.dynamicImports = [];
        }
        if (!state.dynamicImports.includes(dependency)) {
            state.dynamicImports.push(dependency);
        }
    }
    return {
        Import(path, state) {
            const { dynamicImports } = state.opts;
            if (!dynamicImports) {
                return;
            }
            const { loader, strictSpecifier } = dynamicImports;
            const sourcePath = getImportSource(path);
            if (strictSpecifier) {
                validateImport(sourcePath, state);
            }
            if (loader) {
                const loaderId = getLoaderRef(path, loader, state);
                path.replaceWith(loaderId);
                incrementMetricCounter(errors.CompilerMetrics.DynamicImportTransform, state);
            }
            if (sourcePath.isStringLiteral()) {
                addDynamicImportDependency(sourcePath.node.value, state);
            }
        },
    };
}

/*
 * Copyright (c) 2023, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
function scopeCssImports ({ types: t }, path) {
    const programPath = path.isProgram() ? path : path.findParent((node) => node.isProgram());
    programPath.get('body').forEach((node) => {
        if (node.isImportDeclaration()) {
            const source = node.get('source');
            if (source.type === 'StringLiteral' && source.node.value.endsWith('.scoped.css')) {
                source.replaceWith(t.stringLiteral(source.node.value + '?scoped=true'));
            }
        }
    });
}

function compilerVersionNumber({ types: t }) {
    return {
        ClassBody(path) {
            if (path.parent.superClass === null) {
                // Components *must* extend from either LightningElement or some other superclass (e.g. a mixin).
                // We can skip classes without a superclass to avoid adding unnecessary comments.
                return;
            }
            // If the class body is empty, we want an inner comment. Otherwise we want it after the last child
            // of the class body. In either case, we want it right before the `}` at the end of the function body.
            if (path.node.body.length > 0) {
                // E.g. `class Foo extends Lightning Element { /*LWC compiler v1.2.3*/ }`
                t.addComment(path.node.body[path.node.body.length - 1], 'trailing', shared.LWC_VERSION_COMMENT, 
                /* line */ false);
            }
            else {
                // E.g. `class Foo extends Lightning Element { bar = 'baz'; /*LWC compiler v1.2.3*/ }`
                t.addComment(path.node, 'inner', shared.LWC_VERSION_COMMENT, /* line */ false);
            }
        },
    };
}

/*
 * Copyright (c) 2023, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
/**
 * The transform is done in 2 passes:
 * - First, apply in a single AST traversal the decorators and the component transformation.
 * - Then, in a second path transform class properties using the official babel plugin "babel-plugin-transform-class-properties".
 * @param api
 */
function LwcClassTransform(api) {
    const { ExportDefaultDeclaration: transformCreateRegisterComponent } = component(api);
    const { Class: transformDecorators } = decorators(api);
    const { Import: transformDynamicImports } = dynamicImports();
    const { ClassBody: addCompilerVersionNumber } = compilerVersionNumber(api);
    return {
        manipulateOptions(opts, parserOpts) {
            parserOpts.plugins.push('classProperties', [
                'decorators',
                { decoratorsBeforeExport: true },
            ]);
        },
        visitor: {
            // The LWC babel plugin is incompatible with other plugins. To get around this, we run the LWC babel plugin
            // first by running all its traversals from this Program visitor.
            Program: {
                enter(path, state) {
                    const engineImportSpecifiers = getEngineImportSpecifiers(path);
                    // Validate the usage of LWC decorators.
                    validateImportedLwcDecoratorUsage(engineImportSpecifiers, state);
                    // Add ?scoped=true to *.scoped.css imports
                    scopeCssImports(api, path);
                },
                exit(path) {
                    const engineImportSpecifiers = getEngineImportSpecifiers(path);
                    removeImportedDecoratorSpecifiers(engineImportSpecifiers);
                    // Will eventually be removed to eliminate unnecessary complexity. Rollup already does this for us.
                    dedupeImports(api)(path);
                },
            },
            Import: transformDynamicImports,
            Class: transformDecorators,
            ClassBody: addCompilerVersionNumber,
            ExportDefaultDeclaration: transformCreateRegisterComponent,
        },
    };
}

exports.default = LwcClassTransform;
/** version: 6.7.2 */
//# sourceMappingURL=index.cjs.js.map
