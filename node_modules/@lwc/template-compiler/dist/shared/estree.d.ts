import type * as t from 'estree';
export declare function isIdentifier(node: t.BaseNode): node is t.Identifier;
export declare function isMemberExpression(node: t.BaseNode): node is t.MemberExpression;
export declare function isArrayExpression(node: t.BaseNode): node is t.ArrayExpression;
export declare function isObjectExpression(node: t.BaseNode): node is t.ObjectExpression;
export declare function isProperty(node: t.BaseNode): node is t.Property;
export declare function isArrowFunctionExpression(node: t.BaseNode): node is t.ArrowFunctionExpression;
export declare function isObjectPattern(node: t.BaseNode): node is t.ObjectPattern;
export declare function isArrayPattern(node: t.BaseNode): node is t.ArrayPattern;
export declare function isRestElement(node: t.BaseNode): node is t.RestElement;
export declare function isAssignmentPattern(node: t.BaseNode): node is t.AssignmentPattern;
export declare function isUnaryExpression(node: t.BaseNode): node is t.UnaryExpression;
export declare function identifier(name: string, config?: Partial<t.Identifier>): t.Identifier;
export declare function isLiteral(node: t.BaseNode): node is t.Literal;
export declare function memberExpression(object: t.MemberExpression['object'], property: t.MemberExpression['property'], config?: Partial<t.MemberExpression>): t.MemberExpression;
export declare function callExpression(callee: t.CallExpression['callee'], args: t.CallExpression['arguments'], config?: Partial<t.CallExpression>): t.CallExpression;
export declare function literal(value: t.SimpleLiteral['value'], config?: Partial<t.SimpleLiteral>): t.SimpleLiteral;
export declare function conditionalExpression(test: t.ConditionalExpression['test'], consequent: t.ConditionalExpression['consequent'], alternate: t.ConditionalExpression['alternate'], config?: Partial<t.ConditionalExpression>): t.ConditionalExpression;
export declare function unaryExpression(operator: t.UnaryExpression['operator'], argument: t.UnaryExpression['argument'], config?: Partial<t.UnaryExpression>): t.UnaryExpression;
export declare function binaryExpression(operator: t.BinaryExpression['operator'], left: t.BinaryExpression['left'], right: t.BinaryExpression['right'], config?: Partial<t.BinaryExpression>): t.BinaryExpression;
export declare function logicalExpression(operator: t.LogicalExpression['operator'], left: t.LogicalExpression['left'], right: t.LogicalExpression['right'], config?: Partial<t.LogicalExpression>): t.LogicalExpression;
export declare function assignmentExpression(operator: t.AssignmentExpression['operator'], left: t.AssignmentExpression['left'], right: t.AssignmentExpression['right'], config?: Partial<t.AssignmentExpression>): t.AssignmentExpression;
export declare function property(key: t.Property['key'], value: t.Property['value'], config?: Partial<t.Property>): t.Property;
export declare function spreadElement(argument: t.Expression): t.SpreadElement;
export declare function assignmentProperty(key: t.AssignmentProperty['key'], value: t.AssignmentProperty['value'], config?: Partial<t.AssignmentProperty>): t.AssignmentProperty;
export declare function objectExpression(properties: t.ObjectExpression['properties'], config?: Partial<t.ObjectExpression>): t.ObjectExpression;
export declare function objectPattern(properties: t.ObjectPattern['properties'], config?: Partial<t.ObjectPattern>): t.ObjectPattern;
export declare function arrayExpression(elements: t.ArrayExpression['elements'], config?: Partial<t.ArrayExpression>): t.ArrayExpression;
export declare function expressionStatement(expression: t.ExpressionStatement['expression'], config?: Partial<t.ExpressionStatement>): t.ExpressionStatement;
export declare function taggedTemplateExpression(tag: Expression, quasi: t.TemplateLiteral): t.TaggedTemplateExpression;
export declare function templateLiteral(quasis: t.TemplateElement[], expressions: t.Expression[]): t.TemplateLiteral;
export declare function assignmentPattern(left: t.Pattern, right: t.Expression): t.AssignmentPattern;
export declare function functionExpression(id: null | t.Identifier, params: t.FunctionExpression['params'], body: t.FunctionExpression['body'], config?: Partial<t.FunctionExpression>): t.FunctionExpression;
export declare function functionDeclaration(id: t.Identifier, params: t.FunctionDeclaration['params'], body: t.FunctionDeclaration['body'], config?: Partial<t.FunctionDeclaration>): t.FunctionDeclaration;
export declare function blockStatement(body: t.BlockStatement['body'], config?: Partial<t.BlockStatement>): t.BlockStatement;
export declare function returnStatement(argument: t.ReturnStatement['argument'], config?: Partial<t.ReturnStatement>): t.ReturnStatement;
export declare function variableDeclarator(id: t.VariableDeclarator['id'], init: t.VariableDeclarator['init'], config?: Partial<t.VariableDeclarator>): t.VariableDeclarator;
export declare function variableDeclaration(kind: t.VariableDeclaration['kind'], declarations: t.VariableDeclaration['declarations'], config?: Partial<t.VariableDeclaration>): t.VariableDeclaration;
export declare function importDeclaration(specifiers: t.ImportDeclaration['specifiers'], source: t.ImportDeclaration['source'], config?: Partial<t.ImportDeclaration>): t.ImportDeclaration;
export declare function importDefaultSpecifier(local: t.ImportDefaultSpecifier['local'], config?: Partial<t.ImportDefaultSpecifier>): t.ImportDefaultSpecifier;
export declare function importSpecifier(imported: t.ImportSpecifier['imported'], local: t.ImportSpecifier['local'], config?: Partial<t.ImportSpecifier>): t.ImportSpecifier;
export declare function exportDefaultDeclaration(declaration: t.ExportDefaultDeclaration['declaration'], config?: Partial<t.ExportDefaultDeclaration>): t.ExportDefaultDeclaration;
export declare function program(body: t.Program['body'], config?: Partial<t.Program>): t.Program;
export declare function comment(content: string): t.Comment;
export type BaseNode = t.BaseNode;
export type Identifier = t.Identifier;
export type MemberExpression = t.MemberExpression;
export type CallExpression = t.CallExpression;
export type SimpleLiteral = t.SimpleLiteral;
export type Literal = t.Literal;
export type BigIntLiteral = t.BigIntLiteral;
export type RegExpLiteral = t.RegExpLiteral;
export type ConditionalExpression = t.ConditionalExpression;
export type UnaryExpression = t.UnaryExpression;
export type BinaryExpression = t.BinaryExpression;
export type LogicalExpression = t.LogicalExpression;
export type AssignmentExpression = t.AssignmentExpression;
export type AssignmentProperty = t.AssignmentProperty;
export type Property = t.Property;
export type ObjectExpression = t.ObjectExpression;
export type ObjectPattern = t.ObjectPattern;
export type ArrayExpression = t.ArrayExpression;
export type ArrayPattern = t.ArrayPattern;
export type RestElement = t.RestElement;
export type ExpressionStatement = t.ExpressionStatement;
export type FunctionExpression = t.FunctionExpression;
export type Expression = t.Expression;
export type FunctionDeclaration = t.FunctionDeclaration;
export type ArrowFunctionExpression = t.ArrowFunctionExpression;
export type AssignmentPattern = t.AssignmentPattern;
export type BlockStatement = t.BlockStatement;
export type ReturnStatement = t.ReturnStatement;
export type VariableDeclarator = t.VariableDeclarator;
export type VariableDeclaration = t.VariableDeclaration;
export type ImportDeclaration = t.ImportDeclaration;
export type ImportDefaultSpecifier = t.ImportDefaultSpecifier;
export type ImportSpecifier = t.ImportSpecifier;
export type ExportDefaultDeclaration = t.ExportDefaultDeclaration;
export type Statement = t.Statement;
export type Program = t.Program;
