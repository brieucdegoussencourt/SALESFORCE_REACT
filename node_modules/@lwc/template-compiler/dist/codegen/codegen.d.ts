import { APIVersion } from '@lwc/shared';
import * as t from '../shared/estree';
import { ChildNode, Expression, ComplexExpression, Literal, LWCDirectiveRenderMode, Root, EventListener, RefDirective, Text, StaticElement, Attribute, KeyDirective } from '../shared/types';
import State from '../state';
export default class CodeGen {
    /** The AST root. */
    readonly root: Root;
    /** The template render mode. */
    readonly renderMode: LWCDirectiveRenderMode;
    /** Indicates whether the generated code should preserve HTML comments or not. */
    readonly preserveComments: boolean;
    /**
     * This flag indicates if the generated code should scope the template fragment id. It is set to
     * true if the template also contains ids.
     *
     * TODO [#1150]: Remove this code once we can figure out how to do this in a deterministic
     * fashion.
     */
    readonly scopeFragmentId: boolean;
    /**
     * The scope keeps track of the identifiers that have been seen while traversing the AST.
     * Currently, we are keeping track of item, index and iterator on the ForEach and ForOf nodes respectively.
     *
     * Scope is used in bindExpression to determine if the expression is a known identifier.
     * A known identifier exists if it exists in the scope chain.
     */
    private scope;
    readonly staticNodes: Set<ChildNode>;
    readonly hoistedNodes: Array<{
        identifier: t.Identifier;
        expr: t.Expression;
    }>;
    /** True if this template contains the lwc:ref directive */
    hasRefs: boolean;
    /**
     * State maintains information about the current compilation configs.
     */
    readonly state: State;
    currentId: number;
    currentKey: number;
    innerHtmlInstances: number;
    usedApis: {
        [name: string]: t.Identifier;
    };
    usedLwcApis: Set<string>;
    slotNames: Set<string>;
    memorizedIds: t.Identifier[];
    referencedComponents: Set<string>;
    apiVersion: APIVersion;
    staticExpressionMap: WeakMap<Attribute | Text, string>;
    constructor({ root, state, scopeFragmentId, }: {
        root: Root;
        state: State;
        scopeFragmentId: boolean;
    });
    generateKey(): number;
    genElement(tagName: string, data: t.ObjectExpression, children: t.Expression): import("estree").CallExpression;
    genCustomElement(tagName: string, componentClass: t.Identifier, data: t.ObjectExpression, children: t.Expression): import("estree").CallExpression;
    genDynamicElement(ctor: t.Expression, data: t.ObjectExpression, children: t.Expression): import("estree").CallExpression;
    genDeprecatedDynamicElement(tagName: string, ctor: t.Expression, data: t.ObjectExpression, children: t.Expression): import("estree").CallExpression;
    genText(value: Array<string | t.Expression>): t.Expression;
    genConcatenatedText(value: Array<string | t.Expression>): t.Expression;
    genComment(value: string): t.Expression;
    genSanitizeHtmlContent(content: t.Expression): t.Expression;
    genFragment(key: t.Expression | t.SimpleLiteral, children: t.Expression, stable?: boolean): t.Expression;
    genIterator(iterable: t.Expression, callback: t.FunctionExpression): import("estree").CallExpression;
    genBind(handler: t.Expression): import("estree").CallExpression;
    genFlatten(children: t.Expression[]): import("estree").CallExpression;
    genScopedId(id: string | t.Expression): t.CallExpression;
    genScopedFragId(id: string | t.Expression): t.CallExpression;
    /**
     * Generates childs vnodes when slot content is static.
     * @param slotName
     * @param data
     * @param children
     */
    getSlot(slotName: string, data: t.ObjectExpression, children: t.Expression): import("estree").CallExpression;
    /**
     * Generates a factory function that inturn generates child vnodes for scoped slot content.
     * @param callback
     * @param slotName
     */
    getScopedSlotFactory(callback: t.FunctionExpression, slotName: t.Expression | t.SimpleLiteral): import("estree").CallExpression;
    genTabIndex(children: [t.Expression]): import("estree").CallExpression;
    getMemorizationId(): import("estree").Identifier;
    genBooleanAttributeExpr(bindExpr: t.Expression): import("estree").ConditionalExpression;
    genEventListeners(listeners: EventListener[]): import("estree").Property;
    genRef(ref: RefDirective): import("estree").Property;
    genKeyExpression(ref: KeyDirective | undefined, slotParentName: string | undefined): import("estree").SimpleLiteral | import("estree").CallExpression;
    /**
     * This routine generates an expression that avoids
     * computing the sanitized html of a raw html if it does not change
     * between renders.
     * @param expr
     * @returns The generated expression
     */
    genSanitizedHtmlExpr(expr: t.Expression): import("estree").ConditionalExpression | import("estree").LogicalExpression;
    private _renderApiCall;
    beginScope(): void;
    private createScope;
    endScope(): void;
    declareIdentifier(identifier: t.Identifier): void;
    /**
     * Searches the scopes to find an identifier with a matching name.
     * @param identifier
     */
    isLocalIdentifier(identifier: t.Identifier): boolean;
    /**
     * Bind the passed expression to the component instance. It applies the following transformation to the expression:
     * - {value} --> {$cmp.value}
     * - {value[index]} --> {$cmp.value[$cmp.index]}
     * @param expression
     */
    bindExpression(expression: Expression | Literal | ComplexExpression): t.Expression;
    genStaticElement(element: StaticElement, slotParentName?: string): t.Expression;
    genStaticParts(element: StaticElement): t.ArrayExpression | undefined;
    genStaticPart(partId: number, data: t.Expression, text: t.Expression): t.CallExpression;
    getStaticExpressionToken(node: Attribute | Text): string;
}
