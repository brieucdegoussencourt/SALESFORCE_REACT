import { CompilerDiagnostic, InstrumentationObject, LWCErrorInfo } from '@lwc/errors';
import { APIVersion } from '@lwc/shared';
import { NormalizedConfig } from '../config';
import { Root, SourceLocation, ParentNode, BaseNode, LWCDirectiveRenderMode, IfBlock, ElseifBlock, ElseBlock } from '../shared/types';
import type { ecmaVersion as EcmaVersion } from 'acorn';
import type { PreparsedExpressionMap } from './expression-complex';
interface ParentWrapper {
    parent: ParentNode | null;
    current: ParentNode;
}
export default class ParserCtx {
    private readonly source;
    readonly config: NormalizedConfig;
    readonly warnings: CompilerDiagnostic[];
    /**
     * Instrumentation object to handle gathering metrics and internal logs for everything happening
     * during this context.
     */
    readonly instrumentation?: InstrumentationObject;
    readonly seenIds: Set<string>;
    readonly seenSlots: Set<string>;
    /**
     * This set is not aware of if-elseif-else blocks.
     */
    readonly seenScopedSlots: Set<string>;
    readonly ecmaVersion: EcmaVersion;
    /**
     * Parsing of template expressions is deferred to acorn, in order to ensure that JavaScript expressions
     * are parsed correctly. As such, we should cache the ESTree AST for each expression, so that the
     * expression need not be re-parsed when the template compiler's AST is being created.
     */
    readonly preparsedJsExpressions?: PreparsedExpressionMap;
    /**
     * 'elementScopes' keeps track of the hierarchy of ParentNodes as the parser
     * traverses the parse5 AST. Each 'elementScope' is an array where each node in
     * the array corresponds to either an IfBlock, ElseifBlock, ElseBlock, ForEach, ForOf, If, Element, Component, or Slot.
     *
     * Currently, each elementScope has a hierarchy of IfBlock > ForBlock > If > Element | Component | Slot.
     * Note: Not all elementScopes will have all the nodes listed above, but when they do, they will appear in this order.
     * We do not keep track of template nodes.
     *
     * Each scope corresponds to the original parse5.Element node.
     */
    private readonly elementScopes;
    /**
     * 'siblingScopes' keeps track of the context from one sibling node to another.
     * This holds the info needed to properly parse lwc:if, lwc:elseif, and lwc:else directives.
     */
    private readonly siblingScopes;
    renderMode: LWCDirectiveRenderMode;
    preserveComments: boolean;
    apiVersion: APIVersion;
    constructor(source: string, config: NormalizedConfig);
    getSource(start: number, end: number): string;
    setRootDirective(root: Root): void;
    /**
     * This method flattens the scopes into a single array for traversal.
     * @param element
     * @yields Each node in the scope and its parent.
     */
    ancestors(element?: ParentNode): IterableIterator<ParentWrapper>;
    /**
     * This method returns an iterator over ancestor nodes, starting at the parent and ending at the root node.
     *
     * Note: There are instances when we want to terminate the traversal early, such as searching for a ForBlock parent.
     * @param predicate This callback is called once for each ancestor until it finds one where predicate returns true.
     * @param traversalCond This callback is called after predicate and will terminate the traversal if it returns false.
     * traversalCond is ignored if no value is provided.
     * @param startNode Starting node to begin search, defaults to the tail of the current scope.
     */
    findAncestor<A extends ParentNode>(predicate: (node: ParentNode) => node is A, traversalCond?: (nodes: ParentWrapper) => unknown, startNode?: ParentNode): A | null;
    /**
     * This method searchs the current scope and returns the value that satisfies the predicate.
     * @param predicate This callback is called once for each sibling in the current scope
     * until it finds one where predicate returns true.
     */
    findInCurrentElementScope<A extends ParentNode>(predicate: (node: ParentNode) => node is A): A | null;
    beginElementScope(): void;
    endElementScope(): ParentNode | undefined;
    addNodeCurrentElementScope(node: ParentNode): void;
    hasSeenSlot(name: string): boolean;
    addSeenSlot(name: string): void;
    private currentElementScope;
    beginSiblingScope(): void;
    endSiblingScope(): void;
    beginIfChain(node: IfBlock): void;
    appendToIfChain(node: ElseifBlock | ElseBlock): void;
    endIfChain(): void;
    getSiblingIfNode(): IfBlock | ElseifBlock | ElseBlock | undefined;
    isParsingSiblingIfBlock(): boolean;
    private currentSiblingContext;
    private currentIfContext;
    private ancestorIfContext;
    private seenSlotsFromAncestorIfTree;
    /**
     * This method recovers from diagnostic errors that are encountered when fn is invoked.
     * All other errors are considered compiler errors and can not be recovered from.
     * @param fn method to be invoked.
     */
    withErrorRecovery<T>(fn: () => T): T | undefined;
    withErrorWrapping<T>(fn: () => T, errorInfo: LWCErrorInfo, location: SourceLocation, msgFormatter?: (error: any) => string): T;
    throwOnError(errorInfo: LWCErrorInfo, error: any, location?: SourceLocation): never;
    /**
     * This method throws a diagnostic error with the node's location.
     * @param errorInfo
     * @param node
     * @param messageArgs
     */
    throwOnNode(errorInfo: LWCErrorInfo, node: BaseNode, messageArgs?: any[]): never;
    /**
     * This method throws a diagnostic error with location information.
     * @param errorInfo
     * @param location
     * @param messageArgs
     */
    throwAtLocation(errorInfo: LWCErrorInfo, location: SourceLocation, messageArgs?: any[]): never;
    /**
     * This method throws a diagnostic error and will immediately exit the current routine.
     * @param errorInfo
     * @param messageArgs
     * @param location
     * @throws
     */
    throw(errorInfo: LWCErrorInfo, messageArgs?: any[], location?: SourceLocation): never;
    /**
     * This method logs a diagnostic warning with the node's location.
     * @param errorInfo
     * @param node
     * @param messageArgs
     */
    warnOnNode(errorInfo: LWCErrorInfo, node: BaseNode, messageArgs?: any[]): void;
    /**
     * This method logs a diagnostic warning with location information.
     * @param errorInfo
     * @param location
     * @param messageArgs
     */
    warnAtLocation(errorInfo: LWCErrorInfo, location: SourceLocation, messageArgs?: any[]): void;
    /**
     * This method logs a diagnostic warning and will continue execution of the current routine.
     * @param errorInfo
     * @param messageArgs
     * @param location
     */
    warn(errorInfo: LWCErrorInfo, messageArgs?: any[], location?: SourceLocation): void;
    private addDiagnostic;
}
export {};
